# Feature Breakdown #23: HTS 스타일 종목 스크리너 및 조건 검색

## 1. 문제 성격 요약

현재 시스템은 고정된 9개 종목(DEFAULT_SYMBOLS)만 지원하고 있으며, 사용자가 **업비트 원화 마켓 전체 종목(상장/폐지에 따라 100~300개 구간에서 수시 변동, 2025-01 현재 132개)**을 탐색하거나 **HTS 스타일의 조건 검색**으로 매매 기회를 찾을 수 없습니다.

이를 해결하기 위해:
1. **전체 종목 리스트 화면**: 업비트 KRW 마켓의 모든 종목을 실시간 가격/거래량과 함께 표시하는 깔끔한 테이블 UI 구현
2. **조건 검색 화면**: HTS처럼 상승률, 거래량, 거래대금, 이동평균선 이격도, 이동평균선 정배열/역배열 등의 조건을 설정하여 종목을 필터링하는 독립 페이지 구현
3. **실시간 데이터 업데이트**: WebSocket 또는 폴링을 통해 실시간 시세 반영

**핵심 목표**:
- 트레이더가 **전체 시장을 한눈에 파악**하고, **기술적 조건으로 매매 후보를 신속하게 탐색**할 수 있는 프로페셔널 도구 제공
- 백엔드에서 지표 계산 로직을 구현하여 프론트엔드 부담 최소화
- 검증/성공기준에 사용되는 수치(예: KRW 마켓 수, 응답 시간)를 구현 착수 전에 최신 업비트 데이터와 이해관계자에게서 다시 확인해 반영

---

## 2. 분해 기준 선정

**선택 기준**: 기능 레이어 + 데이터 흐름 + UI 복잡도

| 분해 축 | 이유 |
|--------|------|
| **기능 레이어** (데이터 수집, 지표 계산, UI) | 백엔드 API, 프론트엔드 화면, 실시간 업데이트 각각 독립적으로 개발 가능 |
| **데이터 흐름** (수집 → 지표 계산 → 필터링 → 표시) | 각 단계가 명확하게 정의되어 병렬 개발 가능 |
| **UI 복잡도** (단순 리스트 vs 조건 빌더) | 전체 리스트 화면이 먼저 완성되어야 조건 검색 화면 구현 가능 |

**이 조합을 사용하면**:
- 백엔드 API를 먼저 완성 → 프론트엔드 UI 개발 가능
- 전체 리스트 화면 완성 → 조건 검색 화면으로 확장
- 각 조건(상승률, 거래량 등)을 독립적인 모듈로 개발 가능

---

## 3. 세부 작업 플랜

### Task 1: 업비트 전체 KRW 마켓 목록 API 구현 (백엔드, 2-3시간, 🔴 높음)

**설명**:
업비트 REST API `/v1/market/all`을 호출하여 KRW 마켓 전체 종목 목록(변동 수량)을 가져오고, 이를 캐싱하여 제공하는 백엔드 API 엔드포인트 구현. 상장/폐지로 인해 수량이 달라지므로 테스트/성공 기준에 사용되는 최소값은 설정값으로 관리한다.

**완료 정의 (DoD)**:
- [x] `GET /api/markets/krw` 엔드포인트 생성 (FastAPI)
  ```python
  @router.get("/markets/krw")
  async def get_krw_markets():
      """업비트 KRW 마켓 전체 종목 목록 조회"""
      # Upbit API: https://api.upbit.com/v1/market/all
      # 응답: [{"market": "KRW-BTC", "korean_name": "비트코인", "english_name": "Bitcoin"}, ...]
      pass
  ```
- [x] Redis 캐싱 추가 (TTL: 1시간, 마켓 목록은 자주 변경되지 않음)
- [x] 응답 모델 정의 (`MarketInfo`: market, korean_name, english_name)
- [x] `settings.MIN_KRW_MARKETS` (기본 80) 설정을 두어 업비트 실제 수량 변경 시 테스트 통과 기준을 쉽게 조정
- [x] Rate limit 준수 (분당 600회, 초당 10회)
- [x] 에러 처리 (Upbit API 실패 시 캐시된 데이터 반환)
- [x] 단위 테스트 작성 (`tests/unit/test_markets_api.py`)
  ```python
  def test_get_krw_markets():
      response = client.get("/api/markets/krw")
      assert response.status_code == 200
      assert len(response.json()) >= settings.MIN_KRW_MARKETS
      assert all(m["market"].startswith("KRW-") for m in response.json())
  ```

**의존성**:
- 선행 작업: 없음
- 병렬 가능: Task 2와 병렬 진행 가능

**리스크/불확실성**:
- **리스크**: Upbit API 장애 시 전체 기능 마비 → 캐시 전략 및 폴백 데이터 필요
- **리스크**: KRW 마켓 수가 많아지면 (500개+) 응답 시간 증가 → 페이지네이션 고려
- **불확실성**: 신규 상장/폐지 종목 실시간 반영 방법 → 캐시 TTL 조정 또는 WebSocket 이벤트

**검증**:
```bash
# 1. API 호출 테스트
curl http://localhost:8000/api/markets/krw | jq '.[0:5]'
# 예상 응답: [{"market": "KRW-BTC", "korean_name": "비트코인", ...}, ...]

# 2. 캐싱 확인
redis-cli GET "markets:krw"

# 3. 테스트 실행
pytest tests/unit/test_markets_api.py -v
```

---

### Task 2: 실시간 시세 API 구현 (백엔드, 3-4시간, 🔴 높음)

**설명**:
업비트 Ticker API 또는 WebSocket을 사용하여 전체 KRW 마켓의 실시간 시세(현재가, 등락률, 거래량, 거래대금)를 제공하는 API 구현. 초기에는 REST Polling 방식으로 시작하고, 추후 WebSocket으로 확장.

**완료 정의 (DoD)**:
- [x] `GET /api/tickers/krw` 엔드포인트 생성
  ```python
  @router.get("/tickers/krw")
  async def get_krw_tickers():
      """업비트 KRW 마켓 전체 종목 실시간 시세 조회"""
      # Upbit API: https://api.upbit.com/v1/ticker?markets=KRW-BTC,KRW-ETH,...
      # 응답: 현재가, 등락률, 거래량, 거래대금 등
      pass
  ```
- [x] Redis 캐싱 (TTL: 3초, 실시간성 유지)
- [x] 응답 모델 정의 (`TickerInfo`: market, trade_price, change_rate, acc_trade_volume_24h, acc_trade_price_24h)
- [x] Rate limit 준수 (한 번에 최대 100개 마켓 조회 가능)
- [x] 전체 KRW 마켓 목록을 100개 단위로 분할해 순차 호출 (마켓 수 증감 시에도 안전하게 동작)
- [x] 에러 처리 및 로깅
- [x] 단위 테스트 작성

**의존성**:
- 선행 작업: Task 1 (마켓 목록 필요)
- 병렬 가능: Task 3과 병렬 진행 가능

**리스크/불확실성**:
- **리스크**: KRW 마켓 수가 100개를 초과하면 단일 호출 시 Rate limit 초과 → 배치 처리 필수
- **리스크**: 실시간성이 떨어질 수 있음 (3초 캐시) → WebSocket 업그레이드 계획 (Task 7)
- **불확실성**: 거래량/거래대금 필드가 Upbit API에서 어떤 단위로 제공되는지 확인 필요

**검증**:
```bash
# 1. API 호출 테스트
curl "http://localhost:8000/api/tickers/krw" | jq '.[0:5]'

# 2. 캐싱 확인
redis-cli GET "tickers:krw"

# 3. 테스트 실행
pytest tests/unit/test_tickers_api.py -v
```

---

### Task 3: 전체 종목 리스트 화면 구현 (프론트엔드, 4-5시간, 🔴 높음)

**설명**:
업비트 KRW 마켓 전체 종목을 **깔끔한 테이블**로 표시하는 React 페이지 구현. 실시간 시세(현재가, 등락률, 거래량, 거래대금)를 표시하고, 정렬/검색/페이지네이션 기능 제공.

**완료 정의 (DoD)**:
- [x] `frontend/src/pages/MarketListPage.jsx` 생성
- [x] Task 1, 2의 API를 호출하여 데이터 로드
  ```jsx
  const [markets, setMarkets] = useState([])  // 마켓 목록
  const [tickers, setTickers] = useState({})  // 실시간 시세 (market -> ticker)

  useEffect(() => {
    // 초기 로드: 마켓 목록
    fetch('/api/markets/krw').then(...)

    // 폴링: 실시간 시세 (3초마다)
    const interval = setInterval(() => {
      fetch('/api/tickers/krw').then(...)
    }, 3000)

    return () => clearInterval(interval)
  }, [])
  ```
- [x] 테이블 UI 구현 (react-table 또는 직접 구현)
  - 컬럼: 심볼, 한글명, 현재가, 등락률, 거래량(24h), 거래대금(24h)
  - 등락률 양수/음수에 따라 색상 표시 (빨강/파랑)
  - 정렬 기능 (모든 컬럼 클릭 시 오름차순/내림차순)
- [x] 검색 기능 (심볼/한글명 필터링)
- [x] 페이지네이션 (50개씩 표시)
- [x] 로딩/에러 상태 처리
- [x] 스타일링 (CSS: 테이블 줄무늬, hover 효과, 반응형)
- [x] 라우팅 추가 (`/markets` 경로)
- [x] 상단 네비게이션에 링크 추가

**의존성**:
- 선행 작업: Task 1, Task 2 (API 완성 필요)
- 병렬 가능: Task 4와 병렬 진행 가능

**리스크/불확실성**:
- **리스크**: KRW 마켓 전체를 한 페이지에 렌더링하면 성능 저하 → 가상화(react-window) 또는 페이지네이션 필수
- **리스크**: 3초마다 폴링하면 불필요한 네트워크 부하 → WebSocket 전환 계획 (Task 7)
- **불확실성**: 사용자가 "이쁘게"의 기준이 모호함 → 와이어프레임 또는 참고 화면 필요 (키움증권 HTS 등)

**검증**:
```bash
# 1. 프론트엔드 개발 서버 실행
cd frontend && npm run dev

# 2. 브라우저에서 http://localhost:5173/markets 접속
# 3. 체크리스트:
#    - QA 시점 업비트 KRW 마켓 수(예: 2025-01 기준 132개)와 페이지 상 노출 수가 일치하는가?
#    - 정렬이 동작하는가? (현재가 클릭 → 오름차순/내림차순)
#    - 검색이 동작하는가? ("비트코인" 입력 → KRW-BTC만 표시)
#    - 페이지네이션이 동작하는가? (1페이지: 1~50, 2페이지: 51~100)
#    - 3초마다 가격이 업데이트되는가? (개발자 도구 Network 탭 확인)
```

---

### Task 4: 기술 지표 계산 모듈 구현 (백엔드, 5-6시간, 🔴 높음)

**설명**:
HTS 스타일 조건 검색을 위한 기술 지표 계산 로직 구현. 백엔드에서 Parquet 데이터를 읽어 **상승률, 거래량, 거래대금, 이동평균선 이격도, 이동평균선 정배열/역배열** 등을 계산하는 모듈 작성.

**완료 정의 (DoD)**:
- [x] `backend/app/indicators/calculator.py` 생성
  ```python
  class IndicatorCalculator:
      def calculate_change_rate(self, df: pd.DataFrame, period: str = '1D') -> float:
          """상승률 계산 (기간: 1D, 1W, 1M)"""
          pass

      def calculate_volume(self, df: pd.DataFrame, period: str = '1D') -> float:
          """거래량 계산 (기간별 합산)"""
          pass

      def calculate_trade_amount(self, df: pd.DataFrame, period: str = '1D') -> float:
          """거래대금 계산 (가격 × 거래량)"""
          pass

      def calculate_ma_divergence(self, df: pd.DataFrame, ma_period: int = 20) -> float:
          """이동평균선 이격도 계산 (현재가 / MA - 1) * 100"""
          pass

      def check_ma_alignment(self, df: pd.DataFrame, ma_periods: Optional[List[int]] = None) -> str:
          """이동평균선 정배열/역배열 판단
          정배열: MA5 > MA20 > MA60 (상승 추세)
          역배열: MA5 < MA20 < MA60 (하락 추세)
          혼조: 그 외
          """
          if ma_periods is None:
              ma_periods = [5, 20, 60]
          pass
  ```
- [x] 각 지표별 단위 테스트 작성 (`tests/unit/test_indicators.py`)
  ```python
  def test_calculate_change_rate():
      # 샘플 데이터: 어제 100원, 오늘 110원 → +10%
      df = pd.DataFrame({
          'timestamp': [yesterday, today],
          'close': [100, 110]
      })
      rate = calculator.calculate_change_rate(df, period='1D')
      assert rate == 10.0
  ```
- [x] 성능 최적화 (벡터화 연산, 불필요한 루프 제거)
- [x] 에러 처리 (데이터 부족 시, NaN 처리)
- [x] 문서화 (각 지표 계산 공식 주석 + 가변 기본값을 피하기 위한 패턴 안내)

**의존성**:
- 선행 작업: 없음 (독립적으로 개발 가능)
- 병렬 가능: Task 1, 2, 3과 병렬 진행 가능

- **리스크**: 전체 KRW 마켓 수(최대 수백 종목) × 복수 지표 계산 시 시간 소요 → 캐싱 및 비동기 처리 필요
- **리스크**: 데이터가 부족한 종목(신규 상장)의 경우 이동평균선 계산 불가 → 기본값 또는 skip 처리
- **불확실성**: "이동평균선 3개의 정배열/역배열"이 정확히 어떤 기간인지 모호 → 5일/20일/60일로 가정, 사용자 설정 가능하도록 확장

**검증**:
```bash
# 1. 단위 테스트 실행
pytest tests/unit/test_indicators.py -v

# 2. 수동 테스트 (Python REPL)
python3 -c "
from backend.app.indicators.calculator import IndicatorCalculator
import pandas as pd

calculator = IndicatorCalculator()
df = pd.read_parquet('/data/KRW-BTC/1D/2025.parquet')
print('상승률 (1D):', calculator.calculate_change_rate(df, '1D'))
print('MA 이격도 (20일):', calculator.calculate_ma_divergence(df, 20))
print('MA 정배열 여부:', calculator.check_ma_alignment(df, [5, 20, 60]))
"
```

---

### Task 5: 조건 검색 API 구현 (백엔드, 4-5시간, 🟡 중간)

**설명**:
Task 4의 지표 계산 모듈을 사용하여, 사용자가 지정한 조건(상승률 > 5%, 거래량 > 1000BTC, MA 정배열 등)에 맞는 종목을 필터링하여 반환하는 API 구현.

**완료 정의 (DoD)**:
- [x] `POST /api/screener/filter` 엔드포인트 생성
  ```python
  @router.post("/screener/filter")
  async def filter_markets(request: ScreenerRequest):
      """
      조건 검색 요청:
      {
        "conditions": [
          {"type": "change_rate", "operator": ">", "value": 5, "period": "1D"},
          {"type": "volume", "operator": ">", "value": 1000, "period": "1D"},
          {"type": "ma_alignment", "operator": "==", "value": "정배열", "ma_periods": [5, 20, 60]}
        ]
      }

      응답:
      {
        "matched_markets": ["KRW-BTC", "KRW-ETH", ...],
        "total_count": 12
      }
      """
      pass
  ```
- [x] 요청 모델 정의 (`ScreenerRequest`, `ScreenerCondition`)
- [x] 응답 모델 정의 (`ScreenerResponse`)
- [x] 조건별 필터링 로직 구현 (Task 4의 calculator 사용)
- [x] Redis 캐싱 (TTL: 1분, 조건 검색 결과는 짧은 시간만 유효)
- [x] 비동기 처리 (전체 KRW 마켓 수 × 여러 조건 계산 시간 소요)
- [x] 에러 처리 (잘못된 조건, 데이터 부족 등)
- [x] 통합 테스트 작성 (`tests/integration/test_screener_api.py`)

**의존성**:
- 선행 작업: Task 4 (지표 계산 모듈 필요)
- 병렬 가능: Task 6과 병렬 진행 가능

**리스크/불확실성**:
- **리스크**: 전체 KRW 마켓 수 × 복수 조건 계산 시 응답 시간 5초 이상 소요 가능 → 비동기 큐(Celery) 또는 프리컴퓨팅 고려
- **리스크**: 조건이 복잡해지면 (10개 이상) 성능 저하 → 조건 수 제한 (최대 5개) 또는 우선순위 처리
- **불확실성**: 사용자가 "AND" 조건인지 "OR" 조건인지 지정할 수 있어야 함 → 요청 모델에 `logic` 필드 추가 (`"AND"` / `"OR"`)

**검증**:
```bash
# 1. API 테스트 (상승률 > 5%)
curl -X POST http://localhost:8000/api/screener/filter \
  -H "Content-Type: application/json" \
  -d '{
    "conditions": [
      {"type": "change_rate", "operator": ">", "value": 5, "period": "1D"}
    ]
  }' | jq

# 예상 응답:
# {
#   "matched_markets": ["KRW-BTC", "KRW-ETH", ...],
#   "total_count": 12
# }

# 2. 복합 조건 테스트 (상승률 > 5% AND 거래량 > 1000)
curl -X POST http://localhost:8000/api/screener/filter \
  -H "Content-Type: application/json" \
  -d '{
    "conditions": [
      {"type": "change_rate", "operator": ">", "value": 5, "period": "1D"},
      {"type": "volume", "operator": ">", "value": 1000, "period": "1D"}
    ],
    "logic": "AND"
  }' | jq

# 3. 통합 테스트 실행
pytest tests/integration/test_screener_api.py -v
```

---

### Task 6: 조건 검색 화면 구현 (프론트엔드, 6-8시간, 🟡 중간)

**설명**:
HTS 스타일의 조건 검색 UI를 구축하는 독립 페이지 구현. 사용자가 **조건을 추가/제거**하고, **조건별 파라미터(기간, 값, 연산자)를 설정**하며, **검색 버튼을 눌러 결과를 확인**할 수 있는 쿼리 빌더 형식의 UI.

**완료 정의 (DoD)**:
- [x] `frontend/src/pages/MarketScreenerPage.jsx` 생성
- [x] 조건 빌더 UI 구현
  ```jsx
  // 조건 타입 드롭다운
  <select>
    <option value="change_rate">상승률</option>
    <option value="volume">거래량</option>
    <option value="trade_amount">거래대금</option>
    <option value="ma_divergence">이동평균선 이격도</option>
    <option value="ma_alignment">이동평균선 정배열/역배열</option>
  </select>

  // 연산자 드롭다운
  <select>
    <option value=">">크다</option>
    <option value="<">작다</option>
    <option value="==">같다</option>
    <option value=">=">크거나 같다</option>
    <option value="<=">작거나 같다</option>
  </select>

  // 값 입력
  <input type="number" placeholder="값 입력" />

  // 기간 드롭다운 (조건에 따라 표시)
  <select>
    <option value="1D">1일</option>
    <option value="1W">1주</option>
    <option value="1M">1개월</option>
  </select>
  ```
- [x] 조건 추가/제거 버튼 (`+ 조건 추가`, `삭제`)
- [x] 조건 논리 연산자 선택 (AND/OR)
- [x] 검색 버튼 클릭 시 Task 5 API 호출
- [x] 검색 결과 테이블 표시 (Task 3의 테이블 컴포넌트 재사용)
- [x] 로딩/에러 상태 처리
- [x] 스타일링 (조건 빌더 카드 형식, 간격, 버튼 디자인)
- [x] 라우팅 추가 (`/screener` 경로)
- [x] 상단 네비게이션에 링크 추가

**의존성**:
- 선행 작업: Task 3 (테이블 컴포넌트 재사용), Task 5 (API 필요)
- 병렬 가능: 없음 (Task 3, 5 완료 후 진행)

**리스크/불확실성**:
- **리스크**: 조건 빌더 UI가 복잡하여 UX가 떨어질 수 있음 → 와이어프레임 필요, 실제 HTS(키움증권 등) 참고
- **리스크**: 이동평균선 이격도/정배열 조건이 초보자에게는 이해하기 어려움 → 툴팁 또는 설명 추가
- **불확실성**: 조건을 저장하거나 프리셋으로 만들 수 있는 기능 필요? → Phase 2로 미루거나 선택사항

**검증**:
```bash
# 1. 프론트엔드 개발 서버 실행
cd frontend && npm run dev

# 2. 브라우저에서 http://localhost:5173/screener 접속
# 3. 체크리스트:
#    - 조건 추가 버튼 클릭 → 새 조건 입력 폼이 추가되는가?
#    - 조건 타입 선택 → 관련 파라미터 입력 필드가 표시되는가?
#    - 검색 버튼 클릭 → API 호출 후 결과 테이블이 표시되는가?
#    - 조건 삭제 버튼 클릭 → 조건이 제거되는가?
#    - 여러 조건 추가 후 AND/OR 선택 → 올바른 결과가 나오는가?
```

---

### Task 7: 실시간 데이터 업데이트 (WebSocket 전환, 선택사항, 4-5시간, 🟢 낮음)

**설명**:
Task 2의 REST 폴링 방식을 **업비트 WebSocket API**로 전환하여 진정한 실시간 시세 업데이트 구현. 프론트엔드에서 WebSocket 연결을 열고, 백엔드는 업비트 WebSocket을 중계하는 프록시 역할.

**완료 정의 (DoD)**:
- [x] 백엔드 WebSocket 프록시 구현 (`backend/app/market_data/upbit_websocket.py` 확장)
  ```python
  @app.websocket("/ws/tickers/krw")
  async def websocket_tickers(websocket: WebSocket):
      await websocket.accept()

      # Upbit WebSocket 연결
      async with websockets.connect("wss://api.upbit.com/websocket/v1") as upbit_ws:
          # 구독 메시지 전송
          await upbit_ws.send(json.dumps([{"ticket": "..."}, {"type": "ticker", "codes": krw_markets}]))

          # 메시지 중계
          async for message in upbit_ws:
              await websocket.send_text(message)
  ```
- [x] 프론트엔드 WebSocket 클라이언트 구현 (`frontend/src/hooks/useWebSocket.js`)
  ```jsx
  const useWebSocket = (url) => {
    const [data, setData] = useState(null)

    useEffect(() => {
      const ws = new WebSocket(url)
      ws.onmessage = (event) => {
        const ticker = JSON.parse(event.data)
        setData(prev => ({...prev, [ticker.market]: ticker}))
      }
      return () => ws.close()
    }, [url])

    return data
  }
  ```
- [x] Task 3의 `MarketListPage`를 WebSocket 사용으로 수정
- [x] 연결 끊김/재연결 로직 구현
- [x] 성능 테스트 (전체 KRW 마켓 실시간 업데이트 시 CPU/메모리 사용량)

**의존성**:
- 선행 작업: Task 2, Task 3 (REST 방식이 먼저 완성되어야 함)
- 병렬 가능: 없음

**리스크/불확실성**:
- **리스크**: WebSocket 연결이 많아지면 서버 부하 증가 → 연결 수 제한 또는 Redis Pub/Sub 사용
- **리스크**: 업비트 WebSocket이 자주 끊어질 수 있음 → 자동 재연결 로직 필수
- **불확실성**: WebSocket이 정말 필요한가? 3초 폴링으로도 충분할 수 있음 → 사용자 피드백 후 결정

**검증**:
```bash
# 1. WebSocket 연결 테스트 (wscat 사용)
wscat -c ws://localhost:8000/ws/tickers/krw

# 2. 브라우저 개발자 도구 → Network → WS 탭에서 메시지 확인
# 3. 프론트엔드에서 실시간 가격 업데이트 확인 (1초 이내)
```

---

## 4. 누락 탐지

다음 항목들을 추가로 확인이 필요합니다:

### 1. "이쁘게" 만드는 기준이 모호함
- **질문**: 사용자가 원하는 "이쁜" UI의 구체적인 예시가 무엇인가?
- **확인 필요**: 키움증권 HTS, 업비트 앱, 바이낸스 스크리너 등의 스크린샷을 참고해야 하는가?
- **조치**: 와이어프레임 또는 레퍼런스 화면을 먼저 확인 후 Task 3, 6 착수

### 2. 조건 검색의 우선순위와 범위
- **질문**: 상승률, 거래량, 거래대금, MA 이격도, MA 정배열/역배열 외에 추가 조건이 필요한가?
  - 예: RSI, MACD, 볼린저 밴드, 거래량 급증 등
- **확인 필요**: MVP에서는 요청한 5가지 조건만 구현하고, 추후 확장하는 것이 맞는가?
- **조치**: Phase 1에서는 5가지 조건만 구현, Phase 2에서 추가 지표 확장

### 3. 데이터 저장 및 히스토리 관리
- **질문**: 조건 검색 결과를 저장하거나 히스토리를 관리할 필요가 있는가?
- **확인 필요**: "오늘의 검색 결과"를 저장하여 나중에 비교하는 기능 필요?
- **조치**: MVP에서는 저장 기능 제외, 실시간 검색만 지원

### 4. 모바일 반응형 지원
- **질문**: 모바일에서도 사용 가능해야 하는가?
- **확인 필요**: 조건 검색 화면은 복잡한 UI이므로 데스크톱 전용으로 제한할 수도 있음
- **조치**: Task 3, 6에서 기본 반응형 지원, 모바일 최적화는 Phase 2

### 5. 성능 목표
- **질문**: 전체 KRW 마켓(시점별 수량 반영) × 복수 조건 검색 시 응답 시간 목표가 어떻게 되는가?
  - 예: 3초 이내, 5초 이내 등
- **확인 필요**: 백엔드에서 모든 계산을 해야 하는가, 아니면 프론트엔드에서 간단한 필터링을 할 수도 있는가?
- **조치**: Task 5에서 응답 시간 측정 후, 필요 시 최적화 (캐싱, 비동기 처리)
### 6. 성공 기준·검증 값 재확인 (Action Item 1)
- **질문**: KRW 마켓 수, 응답 시간, UI 체크리스트 등 성공 기준에 명시된 수치를 어떤 지표로 측정하고 어느 범위를 허용할 것인가?
- **확인 필요**: 스프린트 시작 전 최신 업비트 데이터를 참고한 뒤, 이해관계자에게 수치를 공유·승인받아 테스트 기준(`settings.MIN_KRW_MARKETS`, 응답 시간 목표 등)에 반영해야 함
- **조치**: 킥오프 미팅에서 성공 기준/검증 방법을 다시 수합하여 문서에 업데이트, 필요 시 회의록 링크 추가

---

## 5. 리파인 제안

다음 반복에서 추가로 확인해야 할 항목:

### A. UI/UX 와이어프레임 작성 (Task 착수 전)
- **전체 리스트 화면**: 테이블 레이아웃, 컬럼 구성, 색상 스키마
- **조건 검색 화면**: 조건 빌더 폼 구조, 검색 버튼 위치, 결과 표시 방식
- 레퍼런스: 키움증권 HTS 조건 검색, 업비트 앱 마켓 리스트

### B. 업비트 API 사용량 및 제한 확인
- Rate limit 테스트: 최신 KRW 마켓 전체를 100개 단위로 배치 조회할 때 제한에 걸리는지 확인
- WebSocket 동시 구독 제한: 한 번에 몇 개 종목까지 구독 가능한지 확인

### C. 기술 스택 선정
- 프론트엔드 테이블 라이브러리: react-table, AG Grid, TanStack Table 중 선택
- 프론트엔드 상태 관리: SWR, React Query, Zustand 등 검토
- 백엔드 비동기 큐: Celery, RQ, FastAPI BackgroundTasks 중 선택

### D. 데이터 캐싱 전략 수립
- Redis TTL 정책: 마켓 목록(1시간), 실시간 시세(3초), 조건 검색 결과(1분)
- Parquet 데이터 로드 최적화: 메모리 캐싱 또는 데이터베이스 마이그레이션 검토

### E. 테스트 데이터 준비
- 샘플 데이터: 상승률 > 5% 종목, 거래량 > 1000 종목 등 미리 생성
- 엣지 케이스: 신규 상장 종목(데이터 부족), 거래 정지 종목 등

---

## 6. 타임라인 및 우선순위

| Task | 선행 작업 | 예상 소요시간 | 우선순위 |
|------|---------|------------|---------|
| Task 1 | 없음 | 2-3시간 | 🔴 높음 (백엔드 기반) |
| Task 2 | Task 1 | 3-4시간 | 🔴 높음 (백엔드 기반) |
| Task 3 | Task 1, 2 | 4-5시간 | 🔴 높음 (UI 우선) |
| Task 4 | 없음 | 5-6시간 | 🔴 높음 (지표 계산 필수) |
| Task 5 | Task 4 | 4-5시간 | 🟡 중간 (조건 검색 API) |
| Task 6 | Task 3, 5 | 6-8시간 | 🟡 중간 (조건 검색 UI) |
| Task 7 | Task 2, 3 | 4-5시간 | 🟢 낮음 (WebSocket, 선택) |

**추천 순서**:
1. **Week 1**: Task 1 + Task 2 (백엔드 API, 5-7시간)
2. **Week 1-2**: Task 3 (전체 리스트 화면, 4-5시간)
3. **Week 2**: Task 4 (지표 계산 모듈, 5-6시간)
4. **Week 2-3**: Task 5 (조건 검색 API, 4-5시간)
5. **Week 3**: Task 6 (조건 검색 화면, 6-8시간)
6. **Week 4** (선택): Task 7 (WebSocket 전환, 4-5시간)

**총 예상 소요시간**: 30-40시간 (Task 7 제외 시 26-35시간)

---

## 7. 성공 기준

✅ **전체 완료 기준**:
- [x] 업비트 KRW 마켓 전체 종목(배포 시점 실시간 수량 기준)이 깔끔한 테이블로 표시됨
- [x] 실시간 시세(현재가, 등락률, 거래량, 거래대금)가 3초마다 업데이트됨
- [x] 정렬/검색/페이지네이션이 모두 동작함
- [x] 조건 검색 화면에서 5가지 조건(상승률, 거래량, 거래대금, MA 이격도, MA 정배열/역배열)을 설정할 수 있음
- [x] 조건 검색 결과가 5초 이내에 표시됨
- [x] 전체 리스트 화면과 조건 검색 화면이 독립된 페이지로 구분됨
- [x] 모든 API가 단위/통합 테스트를 통과함
- [x] 상기 성공 기준과 검증 수치는 스프린트 착수 시점에 최신 업비트 데이터·이해관계자 확인을 거쳐 재조정됨

**최종 결과물**:
```
전체 종목 리스트 화면 (/markets)
  ↓
실시간 시세 표시 (3초 폴링 또는 WebSocket)
  ↓
조건 검색 화면 (/screener)
  ↓
조건 설정 (상승률, 거래량, MA 등)
  ↓
검색 결과 표시 (필터링된 종목 리스트)
```

---

## 8. 참고 자료

### Upbit API 문서
- Market 목록: `GET https://api.upbit.com/v1/market/all`
- Ticker 조회: `GET https://api.upbit.com/v1/ticker?markets=KRW-BTC,KRW-ETH,...`
- WebSocket: `wss://api.upbit.com/websocket/v1`
- Rate limit: 분당 600회, 초당 10회

### 기존 코드
- `backend/app/market_data/upbit_websocket.py` - WebSocket 클라이언트 기존 구현
- `scripts/fetch_upbit_candles.py` - Upbit API 호출 예제
- `frontend/src/pages/DataManagementPage.jsx` - 테이블 UI 참고

### 레퍼런스
- 키움증권 HTS 조건 검색 화면
- 업비트 앱 마켓 리스트
- 바이낸스 스크리너: https://www.binance.com/en/markets/screener

---

## 9. 추가 고려사항

### 9.1 확장 가능성 (Phase 2 예정)
- **알림 기능**: 조건에 맞는 종목이 나타나면 알림 전송
- **조건 저장**: 자주 사용하는 조건을 프리셋으로 저장
- **백테스팅 연동**: 조건 검색 결과를 바로 백테스트에 사용
- **차트 통합**: 종목 클릭 시 차트 팝업 표시

### 9.2 성능 최적화 전략
- **프리컴퓨팅**: 매일 00시에 전체 종목의 지표를 미리 계산하여 Redis에 저장
- **인덱싱**: PostgreSQL에 지표 테이블을 만들고 인덱스 생성
- **캐싱 계층**: L1(메모리), L2(Redis), L3(DB)
- **배치 처리**: 전체 KRW 마켓을 50개씩 나눠 병렬 처리 (수량 변동 시에도 대응)

### 9.3 보안 고려사항
- **Rate limit**: 사용자별 조건 검색 횟수 제한 (분당 10회)
- **입력 검증**: 조건 값 범위 제한 (상승률 -100% ~ +1000% 등)
- **DoS 방어**: 복잡한 조건(10개 이상)은 차단

---

**작성자**: Claude Code (Feature Breakdown #23)
**생성일**: 2025-11-12
**상태**: 📋 계획 수립 완료
