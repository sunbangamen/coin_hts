# 이슈 #15: [Phase 3] MVP 운영 안정성 확보

## 1. 이슈 정보

- **번호**: #15
- **제목**: [Phase 3] MVP 운영 안정성 확보 - 비동기 큐, 결과 파일 관리, 문서화
- **상태**: OPEN
- **작성자**: sunbangamen
- **생성일**: 2025-11-04
- **라벨**: 없음
- **담당자**: 없음

---

## 2. 문제 이해

### 핵심 요구사항
백테스트 엔진의 핵심 기능(Phase 1-2)과 성능 최적화는 완료되었으나, 프로덕션 환경에서 안정적으로 운영하기 위한 인프라 요소 구축이 필요합니다:

1. **비동기 태스크 큐**: 장시간 백테스트 작업을 비동기로 처리하고 진행률 모니터링
2. **결과 파일 저장 구조**: 태스크 결과를 체계적으로 관리하는 디렉터리 구조 및 정리 전략
3. **운영 문서화**: 설치, 실행, 모니터링, 트러블슈팅 가이드

### 전제 조건
- Phase 1-2 완료 (핵심 백테스트 기능)
- Phase 3-1, 3-2-1 완료 (Equity Curve 차트 + 성능 최적화)
- 기존 Docker Compose 환경 및 `/data` 볼륨 마운트 구조 호환성 유지
- 성능 기준선 유지: 1000 캔들 백테스트 1초 이내

### 성공 기준
- ✅ 비동기 백테스트 안정 실행 + React 진행률 폴링 UI
- ✅ `DATA_ROOT/tasks/<task_id>/` 구조 결과 저장 + manifest.json + 정리 스크립트
- ✅ 기존 75개 pytest 통과 + 비동기 end-to-end 시나리오 검증
- ✅ README, operations.md, migration_checklist.md 완성
- ✅ 성능 기준선 유지 (1000 캔들 1초 이내)

---

## 3. 해결 계획

### **Step 1: 비동기 태스크 큐 기술 선택 및 POC** (Task 3.1 선행)
**예상 일정: 1-2일**

| 작업 | 설명 | 산출물 | 확인 방법 |
|------|------|--------|----------|
| Celery vs RQ 비교 | 설정 복잡도, 성능, 모니터링 편의성 비교 | 기술 선택 문서 | POC 실행 결과 |
| Redis 컨테이너 추가 | Docker Compose에 Redis 서비스 추가 | `docker-compose.yml` | `docker-compose up` 정상 실행 |
| 태스크 ID 발급 | `/api/backtest/run`에서 `uuid4()` 기반 태스크 ID 발급 | API 엔드포인트 | Postman/curl 테스트 |
| 상태 저장/조회 설계 | 태스크 상태 저장소(예: Redis 해시) 구조 정의, TTL/정리 정책 포함 | 상태 관리 스펙 문서 | 설계 리뷰 |
| 상태 조회 API 구현 | `/api/backtest/status/{task_id}` 엔드포인트 | API 엔드포인트 | JSON 스키마 검증 |

**의존성**: 없음
**위험 요소**: Celery 설정 복잡도가 높을 경우 RQ로 전환 필요, 상태 저장소 모델 확정 지연 시 후속 작업 지연

---

### **Step 2: 비동기 태스크 큐 전체 구현** (Task 3.1)
**예상 일정: 2-3일**

| 작업 | 설명 | 산출물 | 확인 방법 |
|------|------|--------|----------|
| 비동기 모드 구현 | FastAPI `/api/backtest/run` 비동기 처리 | 워커 코드 | 태스크 큐 등록 확인 |
| 진행률 콜백 삽입 | 백테스트 엔진에 `progress_callback()` 추가 | 엔진 코드 | 진행률 업데이트 확인 |
| React 폴링 UI | 대기/실행/진행률/완료/실패 상태 UI | React 컴포넌트 | 브라우저 테스트 |
| 실패/재시도 전략 구현 | 재시도 횟수, 타임아웃, 치명 실패 시 알림 경로 정의 | 워커 설정/문서 | 테스트 케이스 검증 |
| 단위 테스트 | 태스크 등록, 상태 조회, JSON 스키마 검증 | pytest 파일 | `pytest` 통과 |
| 통합 테스트 | 1000+ 캔들 비동기 실행 및 결과 반환, 장애 시 재시도 경로 확인 | pytest 파일 | 타임아웃 없이 완료 |

**의존성**: Step 1 완료
**위험 요소**: 장시간 실행 태스크에서 Redis 메모리 부족 가능성, 실패 처리 누락 시 장애 확산 위험

---

### **Step 3: 결과 파일 관리 구조 구현** (Task 3.2)
**예상 일정: 2-3일** (Step 1 설계 확정 후 Step 2와 병렬 진행)

| 작업 | 설명 | 산출물 | 확인 방법 |
|------|------|--------|----------|
| 공유 볼륨 설정 | Docker Compose `${DATA_ROOT:-./data}` 볼륨 설정 | `docker-compose.yml` | 볼륨 마운트 확인 |
| 환경 변수 정의 | `DATA_ROOT`, `TASK_RESULT_TTL_DAYS`(기본 7일) 등 | `.env.sample` | 환경 변수 로드 확인 |
| manifest.json 스키마 | task_id, strategy_id, params, result_files, timestamps 등 | 스키마 문서 | JSON 검증 |
| 결과 저장 로직 | 워커에서 `DATA_ROOT/tasks/<task_id>/` 생성 | 워커 코드 | 결과 파일 생성 확인 |
| 정리 스크립트 | `scripts/cleanup_task_results.py` 구현 | Python 스크립트 | 만료 데이터 삭제 확인 |
| result_path 추가 | `/api/backtest/status/{task_id}` 응답에 추가 | API 코드 | API 응답 검증 |

**의존성**: Step 1 설계 산출물 (결과 저장 위치/상태 저장 모델 확정)
**위험 요소**: 다중 워커 환경에서 파일 경합 가능성 (task_id 기반 분리로 해결)

---

### **Step 4: 통합 테스트 및 회귀 테스트** (Task 3.4)
**예상 일정: 1-2일**

| 작업 | 설명 | 산출물 | 확인 방법 |
|------|------|--------|----------|
| 기존 pytest 실행 | 75개 테스트 모두 통과 확인 | 테스트 결과 | `pytest` 출력 |
| 비동기 end-to-end | React → 비동기 실행 → 폴링 → 결과 확인 | 시나리오 테스트 | Playwright 등 자동화 + 수동 보강 |
| 결과 디렉터리 검증 | manifest + 결과 파일 생성 확인 | 테스트 스크립트 | 파일 존재 확인 |
| 정리 스크립트 검증 | 만료 대상만 삭제 확인 | 테스트 스크립트 | 삭제 로그 확인 |
| 성능 기준선 검증 | 1000 캔들 1초 이내 | 벤치마크 결과 | 시간 측정 |

**의존성**: Step 2, Step 3 완료
**위험 요소**: 회귀 테스트 실패 시 기존 기능 영향 조사 필요

---

### **Step 5: 운영 문서 작성** (Task 3.3)
**예상 일정: 2-3일**

| 작업 | 설명 | 산출물 | 확인 방법 |
|------|------|--------|----------|
| README 업데이트 | 프로젝트 개요, 설치, 빠른 시작, 비동기 모드 사용법 | `README.md` | 신규 사용자 테스트 |
| operations.md | 워커 모니터링, Redis 관리, 결과 백업/정리, 로그, 에러 해결 | `docs/operations.md` | 문서 리뷰 |
| migration_checklist.md | Phase 1-2 → Phase 3 전환 절차, 환경 변수, 보안 항목 | `docs/migration_checklist.md` | 체크리스트 검증 |
| 신규 사용자 테스트 | 문서만으로 시스템 설치/실행 가능 확인 | 테스트 결과 | 피드백 수집 |

**의존성**: Step 2, Step 3 완료
**위험 요소**: 문서 불충분 시 추가 iteration 필요

---

## 4. 우선순위 및 일정

| 단계 | 우선순위 | 예상 일정 | 병렬 가능 |
|------|---------|---------|----------|
| Step 1 | CRITICAL | 1-2일 | ⚠️ (Step 3 스키마 초안 정도만 병렬 가능) |
| Step 2 | CRITICAL | 2-3일 | ✅ (Step 1 완료 후 Step 3와 병렬) |
| Step 3 | HIGH | 2-3일 | ✅ (Step 1 설계 확정 후 Step 2와 병렬) |
| Step 4 | HIGH | 1-2일 | ❌ (Step 2, 3 완료 후) |
| Step 5 | MEDIUM | 2-3일 | ❌ (Step 2, 3 완료 후) |

**전체 예상 일정**: 8-13일 (병렬 작업 고려 시 6-9일)

---

## 5. 불확실성 및 질문

1. **Celery vs RQ 선택 기준**
   - 현재 팀의 Python/Redis 숙련도는?
   - 향후 복잡한 워크플로우(체인, 그룹) 필요 여부는?
   - → **제안**: RQ부터 시작 (간단, 빠른 구현) → 필요시 Celery 전환

2. **결과 파일 보존 정책**
   - `TASK_RESULT_TTL_DAYS` 기본값 7일 유지에 대한 의견은?
   - 장기 보존이 필요한 결과는 태그/백업 등 별도 프로세스로 분리할 것인지?
   - 정리 스크립트 실행 주기 및 모니터링 방식을 어떻게 가져갈지?

3. **모니터링 도구**
   - Celery Flower 등 모니터링 UI 필요 여부?
   - 프로덕션 환경에서 로그 수집 인프라(ELK, Datadog 등) 사용 계획?

---

## 6. 사용자 확인 요청

위 계획으로 진행해도 될까요? 특히 다음 사항을 확인하고 싶습니다:

1. **Step 1-3 연계 진행**: Step 1 설계 확정 이후 Step 3 개발을 병렬 진행하는 일정에 동의하시나요? (설계 확정 전에는 스키마 초안 등 선행 작업만 진행)
2. **기술 선택**: Celery vs RQ 중 선호하는 방향이 있으신가요? (없으면 RQ POC부터 시작 제안)
3. **실패 대응 및 모니터링**: 재시도/알림 정책과 모니터링 도구 요구사항에 추가 의견이 있으신가요?
4. **결과 보존 정책**: TTL 기본값(7일) 및 장기 보존 예외 케이스에 대한 요구사항이 있으신가요?

승인해 주시면 바로 작업을 시작하겠습니다.
