# GitHub Issue #35 분석 및 해결 계획

## 1. 이슈 정보 수집

### 기본 정보
- **이슈 번호**: #35
- **제목**: [Phase 2] 심볼 활성/비활성 토글 UI 및 API 전체 구현
- **상태**: OPEN
- **생성일**: 2025-11-11 07:54:35 UTC
- **최종 업데이트**: 2025-11-11 07:54:35 UTC

### 핵심 요구사항
Phase 2의 "시그널 뷰어 & 관리" 단계 완성을 위한 심볼별 활성/비활성 토글 기능 구현:
- 사용자가 백테스트 결과에서 각 심볼의 활성 여부를 동적으로 관리
- 백엔드 API, 프론트엔드 UI, 데이터 레이어 전체 구현

### 현재 상태
- ✅ 백엔드: 결과 조회 API 완성 (`/api/backtests/latest`, `/history`, `/{run_id}`)
- ⚠️ 백엔드: 심볼 상태 관리 API 부재
- ⚠️ 프론트엔드: SignalViewerPage 기본 UI만 구현 (321-449줄)
- ⚠️ 데이터: 결과 JSON에 활성 상태 필드 없음

---

## 2. 문제 이해

### 핵심 문제점
1. **데이터 모델 부재**: `SymbolResult`에 `is_active` 필드가 없음
2. **API 엔드포인트 부재**: 심볼 토글을 위한 PATCH/PUT API가 없음
3. **프론트엔드 컴포넌트 부재**: 토글 UI 컴포넌트가 없음
4. **통합 테스트 부재**: 전체 흐름 검증 필요

### 의존성 분석
```
Task 1 (데이터 모델)
    ↓
Task 2 (백엔드 API) ← Task 3 (프론트엔드 UI)
    ↓                     ↓
    Task 4 (통합 테스트 & 문서화)
```

### 위험 요소
1. **Q1: 전역 vs. 실행별 활성 상태**
   - 각 run_id마다 독립 관리 vs. 전역 설정 참조?
   - **권장**: 실행별 독립 관리 (백테스트 결과 무결성 유지)

2. **Q2: 파일 기반 저장 시 동시성 문제**
   - TOCTOU (Time-of-Check-Time-of-Use) 가능성
   - **완화책**: 파일 lock 메커니즘 (fcntl 활용, 이미 result_manager.py에 구현됨)

3. **Q3: 대형 파일 성능**
   - 100MB+ 결과 파일 로드 시 성능 저하
   - **완화책**: 부분 업데이트 또는 인덱스 캐싱

4. **Q4: 하위 호환성**
   - 기존 결과 파일에 `is_active` 필드 없음
   - **완화책**: 로드 시 기본값(True) 자동 적용

---

## 3. 해결 계획 수립

### Task 1: 데이터 모델 확장 (2일)
**목표**: `SymbolResult`에 `is_active` 필드 추가 및 저장/로드 로직 구현

**구현 단계**:
1. `backend/app/main.py:186-202` - `SymbolResult` 모델 수정
   ```python
   class SymbolResult(BaseModel):
       symbol: str
       is_active: bool = Field(default=True, description="심볼 활성화 여부")
       signals: List[APISignal] = ...
       # ... 나머지 필드
   ```

2. `backend/app/result_manager.py:425-482` - `save_result()` 원자성 강화
   - 현재 결과 JSON은 잠금 없이 직접 덮어쓰므로 PATCH 경쟁 시 손상 위험
   - `fcntl.flock`으로 쓰기 잠금을 잡고 `run_id.json.tmp`에 기록 후 `os.replace`로 원자적으로 교체하는 로직을 추가
   - 이 수정이 있어야 Task 2에서 동시에 토글 요청이 들어와도 데이터가 안전하게 유지됨

3. `backend/app/main.py:467-675` - `run_backtest()` 엔드포인트 수정
   ```python
   symbol_results.append(
       SymbolResult(
           symbol=symbol,
           is_active=True,  # 기본값
           signals=api_signals,
           # ... 나머지 필드
       )
   )
   ```

4. 하위 호환성 처리 (레거시 JSON 백필)
   - `ResultManager.get_result()`에서 `result_data["symbols"]`를 순회하며 `SymbolResult(**symbol_dict)`로 재검증 → `model_dump()` 결과를 다시 배열에 넣어 기본값을 주입
   - 이 normalization 단계를 추가하지 않으면 기존 JSON은 여전히 `is_active`가 없어 UI/API가 `None`을 받게 되므로 **필수**

5. 유닛 테스트 작성
   ```python
   # tests/unit/test_symbol_result.py
   def test_symbol_result_with_is_active():
       # is_active 필드가 포함된 SymbolResult 생성 및 검증

   def test_symbol_result_backward_compatibility():
       legacy = {"symbol": "BTC_KRW", "signals": [], "win_rate": 0.55, ...}
       normalized = hydrate_symbol_with_defaults(legacy)
       assert normalized["is_active"] is True
   ```

**산출물**:
- 수정된 `SymbolResult` 모델 (is_active 필드 포함)
- 유닛 테스트 (2개 이상)

---

### Task 2: 백엔드 API 구현 (3일)
**목표**: 심볼 토글을 위한 API 엔드포인트 구현

**구현 단계**:

1. **PATCH /api/backtests/{run_id}/symbols/{symbol}** (개별 토글)
   ```python
   @app.patch("/api/backtests/{run_id}/symbols/{symbol}")
   async def toggle_symbol_active(
       run_id: str,
       symbol: str,
       is_active: bool = Body(..., embed=True)
   ):
       """
       특정 심볼의 활성 상태 토글

       Args:
           run_id: 백테스트 실행 ID
           symbol: 심볼명 (예: BTC_KRW)
           is_active: 활성화 여부

       Returns:
           업데이트된 SymbolResult
       """
       # 1. 결과 파일 로드
       result_data = ResultManager.get_result(DATA_ROOT, run_id)
       if not result_data:
           raise HTTPException(404, "Backtest result not found")

       # 2. 심볼 찾기 및 업데이트
       symbols = result_data.get("symbols", [])
       symbol_found = False
       for sym in symbols:
           if sym.get("symbol") == symbol:
               sym["is_active"] = is_active
               symbol_found = True
               break

       if not symbol_found:
           raise HTTPException(404, f"Symbol {symbol} not found")

       # 3. 결과 저장 (원자적 쓰기)
       if not ResultManager.save_result(DATA_ROOT, run_id, result_data):
           raise HTTPException(500, "Failed to update result")

       return {"symbol": symbol, "is_active": is_active}
   ```

2. **결과 저장 시 동시성 보장**
   - 위 PATCH 핸들러는 `ResultManager.save_result()`가 원자적으로 동작한다는 전제이므로 Task 1에서 추가한 잠금/임시파일 로직을 호출 전후로 포함해야 함
   - 저장 실패 시 500을 반환하고, 성공 시 최신 normalized 데이터를 다시 반환하여 프론트엔드가 즉시 반영하도록 한다

3. **PUT /api/backtests/{run_id}/symbols** (일괄 업데이트, 선택사항)
   ```python
   class BulkSymbolUpdate(BaseModel):
       updates: List[Dict[str, bool]]  # [{"symbol": "BTC_KRW", "is_active": true}, ...]

   @app.put("/api/backtests/{run_id}/symbols")
   async def bulk_update_symbols(run_id: str, request: BulkSymbolUpdate):
       """여러 심볼의 활성 상태를 한 번에 업데이트"""
       # 구현 로직...
   ```

4. **GET/PUT /api/strategies/active_symbols** (전역 설정, 선택사항)
   - 향후 확장을 위한 전역 활성 심볼 관리
   - 우선순위 낮음, Phase 3 고려

5. **에러 핸들링**
   - 404: run_id 또는 symbol 미존재
   - 400: 잘못된 요청 형식
   - 500: 파일 저장 실패

6. **통합 테스트 작성**
   ```python
   # tests/integration/test_symbol_toggle_api.py
   def test_toggle_symbol_active_success():
       # 정상 토글 시나리오

   def test_toggle_symbol_not_found():
       # 존재하지 않는 심볼 토글 시 404 반환

   def test_toggle_concurrent_updates():
       # 동시 업데이트 시나리오 (파일 lock 검증)
   ```

7. **API 문서 작성**
   - `docs/coin/mvp/SYMBOL_TOGGLE_API.md` 생성
   - OpenAPI 스펙 업데이트 (main.py의 docstring 활용)

**산출물**:
- PATCH 엔드포인트 구현
- 통합 테스트 (3개 이상)
- API 문서

---

### Task 3: 프론트엔드 UI 구현 (4일)
**목표**: SignalViewerPage에 토글 컴포넌트 추가 및 API 통합

**구현 단계**:

1. **SymbolToggleList 컴포넌트 생성**
   ```jsx
   // frontend/src/components/SymbolToggleList.jsx
   import { useState } from 'react'

   export default function SymbolToggleList({ runId, symbols, onToggle }) {
     const [isUpdating, setIsUpdating] = useState(false)

     const handleToggle = async (symbolItem) => {
       setIsUpdating(true)
       try {
         const response = await fetch(
           `/api/backtests/${runId}/symbols/${symbolItem.symbol}`,
           {
             method: 'PATCH',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ is_active: !symbolItem.is_active })
           }
         )

         if (!response.ok) throw new Error('Failed to toggle')

         const updated = await response.json()
         onToggle(updated)
       } catch (error) {
         console.error('Toggle failed:', error)
       } finally {
         setIsUpdating(false)
       }
     }

     return (
       <div className="symbol-toggle-list">
         <h4>심볼 활성화 관리</h4>
         {symbols.map(symbol => (
           <div key={symbol.symbol} className="symbol-toggle-item">
             <label>
               <input
                 type="checkbox"
                 checked={symbol.is_active}
                 onChange={() => handleToggle(symbol)}
                 disabled={isUpdating}
               />
               <span className={symbol.is_active ? 'active' : 'inactive'}>
                 {symbol.symbol}
               </span>
             </label>
           </div>
         ))}
       </div>
     )
   }
   ```

2. **SignalViewerPage 통합**
   - `frontend/src/pages/SignalViewerPage.jsx:321-449` 수정
   ```jsx
   import SymbolToggleList from '../components/SymbolToggleList'

   function LatestResultCard({ data, loading, error }) {
     const [symbols, setSymbols] = useState(data?.symbols || [])

     const handleSymbolToggle = (updated) => {
       setSymbols(prev => prev.map(s =>
         s.symbol === updated.symbol ? { ...s, is_active: updated.is_active } : s
       ))
     }

     // ...

     return (
       <div className="card latest-result-card">
         {/* 기존 내용 */}

         <SymbolToggleList
           runId={data.run_id}
           symbols={symbols}
           onToggle={handleSymbolToggle}
         />

         {/* 비활성 심볼 필터링 적용 */}
         <div className="symbols-performance">
           {symbols.filter(s => s.is_active).map(symbol => (
             // 활성 심볼만 표시
           ))}
         </div>
       </div>
     )
   }
   ```

3. **SignalsTable 필터링 로직**
   - 비활성 심볼은 회색 처리 또는 숨김
   ```jsx
   function SignalsTable({ signals, activeSymbols }) {
     const filteredSignals = signals.filter(sig =>
       activeSymbols.includes(sig.symbol)
     )
     // ...
   }
   ```

4. **로딩 상태 표시**
   - 토글 중 스피너 표시
   - 에러 발생 시 토스트 메시지

5. **스타일 적용**
   ```css
   /* frontend/src/App.css */
   .symbol-toggle-list {
     margin: 1rem 0;
     padding: 1rem;
     border: 1px solid #ddd;
     border-radius: 8px;
   }

   .symbol-toggle-item {
     display: flex;
     align-items: center;
     padding: 0.5rem;
   }

   .symbol-toggle-item label {
     display: flex;
     align-items: center;
     cursor: pointer;
   }

   .symbol-toggle-item .inactive {
     color: #999;
     text-decoration: line-through;
   }
   ```

6. **공통 타입 정의 업데이트**
   - `frontend/src/utils/charts.ts`의 `export interface SymbolResult`에 `is_active: boolean;`을 추가하고 이를 사용하는 모든 훅/컴포넌트가 새 필드를 참조하도록 리팩터링
   - 백엔드 `BacktestResponse` 스키마가 확장되므로 API 응답 타입(`frontend/src/api/types.ts` 등)이 있으면 동일하게 업데이트

7. **유닛/통합 테스트**
   ```javascript
   // tests/frontend/SymbolToggleList.test.jsx
   import { render, fireEvent, waitFor } from '@testing-library/react'
   import SymbolToggleList from '../components/SymbolToggleList'

   test('renders symbol toggle list', () => {
     // 렌더링 검증
   })

   test('toggles symbol active state', async () => {
     // 토글 동작 검증
   })
   ```

**산출물**:
- SymbolToggleList 컴포넌트
- SignalViewerPage 통합
- CSS 스타일
- 프론트엔드 테스트 (2개 이상)

---

### Task 4: 통합 테스트 & 문서화 (3일)
**목표**: 전체 흐름 검증 및 사용자 가이드 작성

**구현 단계**:

1. **통합 테스트 작성**
   ```python
   # tests/integration/test_symbol_toggle_e2e.py
   def test_symbol_toggle_full_workflow():
       """
       전체 워크플로우:
       1. 백테스트 실행
       2. 결과 조회
       3. 심볼 토글
       4. 프론트엔드 반영 확인
       """
       # 1. 백테스트 실행
       response = client.post("/api/backtests/run", json={...})
       run_id = response.json()["run_id"]

       # 2. 결과 조회
       result = client.get(f"/api/backtests/{run_id}").json()
       assert result["symbols"][0]["is_active"] == True

       # 3. 심볼 토글
       toggle = client.patch(
           f"/api/backtests/{run_id}/symbols/BTC_KRW",
           json={"is_active": False}
       )
       assert toggle.status_code == 200

       # 4. 변경사항 확인
       updated = client.get(f"/api/backtests/{run_id}").json()
       assert updated["symbols"][0]["is_active"] == False
   ```

2. **E2E 테스트 (선택사항)**
   - Selenium/Playwright를 사용한 브라우저 자동화
   - 우선순위 낮음

3. **API 문서 작성**
   ```markdown
   # docs/coin/mvp/SYMBOL_TOGGLE_API.md

   ## 심볼 활성/비활성 토글 API

   ### PATCH /api/backtests/{run_id}/symbols/{symbol}

   **요청**:
   ```json
   {
     "is_active": false
   }
   ```

   **응답**:
   ```json
   {
     "symbol": "BTC_KRW",
     "is_active": false
   }
   ```

   ### 에러 코드
   - 404: run_id 또는 symbol 미존재
   - 400: 잘못된 요청
   - 500: 서버 오류
   ```

4. **운영 가이드 작성**
   ```markdown
   # docs/coin/mvp/SIGNAL_VIEWER_USER_GUIDE.md

   ## 시그널 뷰어 사용 가이드

   ### 심볼 활성화 관리
   1. 시그널 뷰어 페이지 접속
   2. 최신 결과 카드에서 "심볼 활성화 관리" 섹션 확인
   3. 체크박스를 클릭하여 심볼 활성/비활성 토글
   4. 비활성 심볼은 회색으로 표시되며 성과 차트에서 제외됨

   ### 문제 해결
   - **토글이 동작하지 않음**: 네트워크 연결 확인, 브라우저 콘솔 로그 확인
   - **변경사항이 반영되지 않음**: 페이지 새로고침 (F5)
   ```

5. **Phase 2 README 업데이트**
   - `docs/coin/mvp/phase2_plan.md` 업데이트
   - 완료 항목 체크 및 스크린샷 추가

6. **백로그 정리**
   - 관련 이슈/태스크 정리
   - 다음 단계 계획 수립

**산출물**:
- 통합 테스트 (1개 이상)
- API 문서
- 운영 가이드
- Phase 2 README 업데이트

---

### Task 5: 현황 검증 및 잔여 작업 정리 (1일)
**목표**: 실제 저장소 상태와 리포트/통계가 일치하도록 검증하고, 누락된 타입 정의를 보완

**구현 단계**:

1. **수치 검증 자동화**
   - `scripts/report_issue35_stats.py` (간단한 Python 스크립트)로 다음 항목을 자동 산출:
     - 백엔드 변경 파일 수 (`backend/app/main.py`, `backend/app/result_manager.py` 현재 2개)
     - 프론트엔드 변경 파일 수 (`SymbolToggleList.jsx`, `SymbolToggleList.css`, `SignalViewerPage.jsx`, `App.css` 등 4개)
     - 테스트 파일/케이스 수 (유닛 10, 통합 10 → 총 20개)
   - 산출된 값으로 `docs/coin/mvp/PHASE2_ISSUE_35_COMPLETION.md` 및 요약 슬라이드의 표를 업데이트

2. **문서 싱크**
   - `docs/coin/mvp/SYMBOL_TOGGLE_API.md`, `SIGNAL_VIEWER_USER_GUIDE.md`에 기재된 라인 수/기능 목록이 실제 구현과 맞는지 교차 검증
   - 불일치 시 diff 근거를 명시하고 최신 값으로 갱신

3. **TypeScript 스키마 보완**
   - `frontend/src/utils/charts.ts:165-173`의 `SymbolResult` 인터페이스에 `is_active: boolean;` 추가
   - 동일 인터페이스를 사용하는 컴포넌트/훅(`SignalsTable`, `MultiSymbolChart`, `useLatestResult` 등)을 검색(`rg "SymbolResult" -n frontend`)하여 새로운 필드를 활용하거나 optional 체킹 추가
   - 변경 후 `npm run lint` / `npm run test -- SymbolToggleList`로 타입 오류가 없는지 확인

4. **요약 보고서 업데이트**
   - `📊 구현 통계`, `🧪 테스트 범위`, `📁 생성된 파일` 섹션을 자동 산출 결과로 교체
   - “19개 테스트” 등 잘못된 문구에는 각 테스트 파일의 실제 케이스 수(예: `tests/unit/test_symbol_result.py` 10개)를 각주 형태로 명시

**산출물**:
- 자동 통계 스크립트 및 실행 로그
- 최신 수치가 반영된 완료 보고서/요약 문서
- `SymbolResult` TypeScript 인터페이스 및 관련 소비자 코드 수정

---

## 4. 예상 일정 (병렬 진행 고려)

| Task | 담당 | 소요 시간 | 시작 | 종료 | 의존성 |
|------|------|---------|------|------|--------|
| 1. 데이터 모델 확장 | 백엔드 | 2일 | Day 1 | Day 2 | 없음 |
| 2. 백엔드 API 구현 | 백엔드 | 3일 | Day 3 | Day 5 | Task 1 |
| 3. 프론트엔드 UI 구현 | 프론트엔드 | 4일 | Day 3 | Day 6 | Task 1 (병렬 가능) |
| 4. 통합 테스트 & 문서화 | 전체 | 3일 | Day 7 | Day 9 | Task 2, 3 |
| 5. 현황 검증 & 타입 보완 | 전체 | 1일 | Day 9 | Day 10 | Task 1-4 |
| **총 리드 타임** | | **~9일** | | | |

**병렬 작업 가능 지점**:
- Task 1 완료 후 Task 2와 Task 3를 동시 진행
- Task 3는 Task 2의 API 문서만 있으면 시작 가능

---

## 5. 사용자 확인 요청

위 계획대로 진행해도 될까요? 추가로 확인이 필요한 사항:

### 질문 1: 활성 상태 관리 범위
- **Option A** (권장): 각 백테스트 실행(run_id)별로 독립적인 활성 상태 관리
  - 장점: 결과 무결성 보장, 이력 추적 용이
  - 단점: 전역 설정 불가

- **Option B**: 전역 활성 심볼 설정 + 실행별 오버라이드
  - 장점: 일관된 설정 관리
  - 단점: 복잡도 증가

→ **어떤 방식을 선호하시나요?**

### 질문 2: UI 배치
- **Option A** (권장): 최신 결과 카드 내부에 토글 리스트 배치
- **Option B**: 별도 사이드바/패널로 분리
- **Option C**: 테이블 헤더에 통합

→ **UI 배치 위치는 어디가 좋을까요?**

### 질문 3: 추가 기능
다음 기능들도 함께 구현할까요? (우선순위 낮음, 별도 이슈로 분리 가능)
- [ ] 전역 활성 심볼 설정 (GET/PUT /api/strategies/active_symbols)
- [ ] 일괄 토글 (전체 활성화/비활성화 버튼)
- [ ] E2E 자동화 테스트 (Selenium/Playwright)

→ **Phase 2에 포함할까요, 아니면 Phase 3로 미룰까요?**

---

계획을 검토하시고 승인 또는 수정 요청을 해주시면, 바로 구현에 착수하겠습니다!
