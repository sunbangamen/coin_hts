# 이슈 #17: [PDR Phase 2] 실시간 시뮬레이션 구현 - 페이퍼 트레이딩 시스템

## 📋 이슈 정보

- **번호**: #17
- **상태**: OPEN
- **생성일**: 2025-11-04
- **라벨**: 없음
- **담당자**: 없음

---

## 🎯 핵심 요구사항

현재 백테스트 시스템을 확장하여 **실시간 페이퍼 트레이딩(Paper Trading) 시스템**을 구축해야 합니다.

**주요 목표**:
1. 업비트 WebSocket을 통한 실시간 캔들 데이터 수집
2. 기존 백테스트 전략 로직을 실시간 환경에 적용
3. 가상 포지션 관리 및 손익 계산
4. 프론트엔드 실시간 모니터링 대시보드

**선행 조건**: Phase 1-3 완료 (백테스트 엔진, 비동기 큐, 성능 최적화)
**제약 조건**: 기존 코드 호환성 유지, Docker 환경 통합, 실거래 없이 시뮬레이션만 수행

---

## 📝 해결 계획

### **Phase 1: 실시간 데이터 수집 인프라 구축 (Task 4.1)**
**예상 기간: 3-5일 | 우선순위: CRITICAL**

#### 작업 내용
1. 업비트 WebSocket 클라이언트 구현
   - 체결 스트림 연결 및 재연결 로직
   - `backend/app/market_data/upbit_websocket.py` 작성

2. 1분봉 캔들 집계 엔진 구현
   - 체결 이벤트 → 1분 단위 OHLCV 집계
   - `backend/app/market_data/candle_builder.py` 작성

3. 데이터 저장 및 복구 로직
   - 완성 캔들을 Postgres `market_candles` 테이블에 영속 저장하고 Redis Stream은 실시간 버퍼/브로드캐스트 전용으로 사용
   - 재시작 시 Postgres 최신 캔들과 Redis 버퍼를 조합해 집계 상태 복원

4. REST API 백필 로직
   - `/v1/candles/minutes/{unit}` 호출로 누락 구간 보충 (최대 200 캔들 단위 청크 요청, 병렬 호출 금지)
   - Rate limit을 고려한 지수 백오프 및 슬롯 기반 재시도 로직 구현

5. 제어 API 구현
   - `POST /api/simulation/start` - 데이터 수집 시작
   - `POST /api/simulation/stop` - 데이터 수집 중지

6. Docker 통합
   - `market-data-collector` 서비스 추가

**산출물**:
- WebSocket 클라이언트 모듈
- 캔들 집계 엔진
- 데이터 수집 제어 API
- 단위/통합 테스트

**리스크**:
- WebSocket 재연결 시 누락 구간 처리 (REST 호출량 급증)
- 다중 심볼 집계 시 CPU 부하
- Redis Stream 메모리 압박

---

### **Phase 2: 실시간 전략 실행 엔진 (Task 4.2)**
**예상 기간: 4-6일 | 우선순위: CRITICAL**

#### 작업 내용
1. 실시간 전략 워커 구현
   - `backend/app/simulation/strategy_runner.py` 작성
   - 캔들 수신 → 전략 실행 → 신호 생성 파이프라인

2. 전략 클래스 확장
   - `initialize_with_history` 메서드 추가
   - 전략 기동 시 최소 윈도우 크기만큼 히스토리 로딩

3. 신호 저장 시스템
   - 생성된 신호를 Postgres `signals` 테이블에 기록하고 Redis Stream은 실시간 소비자 전달용으로 사용
   - `signals` 테이블 스키마 및 Stream 채널 설계

4. 전략 설정 API
   - `GET /api/simulation/strategies` - 전략 목록 조회
   - `POST /api/simulation/strategies` - 전략 설정 업데이트

5. Docker 통합
   - `strategy-runner` 서비스 추가

**산출물**:
- 실시간 전략 실행 워커
- 전략 인터페이스 확장
- 전략 설정 API
- Mock 캔들 기반 단위 테스트

**리스크**:
- 전략별 히스토리 요구량 차이 → 초기화 시간 증가
- 다중 심볼/전략 동시 실행 시 CPU 사용률
- 백테스트 코드 호환성 유지

**의존성**: Task 4.1 완료 (캔들 포맷 확정)

---

### **Phase 3: 가상 포지션 관리 시스템 (Task 4.3)**
**예상 기간: 3-4일 | 우선순위: HIGH**

#### 작업 내용
1. 포지션 관리 모듈 구현
   - `backend/app/simulation/position_manager.py` 작성
   - Postgres `simulation_positions`/`simulation_trades` 테이블 설계, Redis Hash는 세션 캐시/버퍼 용도로 제한

2. 포지션 진입/청산 로직
   - BUY 신호 → 포지션 진입 (가상 체결가 결정)
   - SELL 신호 → 포지션 청산 (실현 손익 계산)

3. 포지션 평가 및 손익 계산
   - 최신 캔들 수신 시 Postgres 기준 미실현 손익 업데이트
   - 수수료/슬리피지 반영

4. 포지션 관리 API
   - `GET /api/simulation/positions` - 현재 포지션 조회
   - `GET /api/simulation/history` - 포지션 이력 조회

**산출물**:
- 포지션 관리 모듈
- 손익 계산 로직
- 포지션 API
- Mock 신호 기반 단위 테스트

**리스크**:
- 가상 체결가 결정 로직 (종가 vs 다음 캔들 시가)
- 동일 심볼에 여러 전략 신호 충돌

**의존성**: Task 4.2 완료, Task 4.1 최신 가격 제공

---

### **Phase 4: 프론트엔드 실시간 대시보드 (Task 4.4)**
**예상 기간: 3-5일 | 우선순위: HIGH**

#### 작업 내용
1. 백엔드 WebSocket 서버
   - `backend/app/simulation/websocket_server.py` 작성
   - 신호/포지션 업데이트 이벤트 broadcast (JWT 기반 인증 및 토큰 만료 처리 포함)

2. React WebSocket 클라이언트
   - `frontend/src/hooks/useSimulation.js` 작성
   - Socket.IO 연결 및 재연결 로직

3. UI 컴포넌트 구현
   - `SignalStream.jsx` - 실시간 신호 스트림
   - `PositionTable.jsx` - 현재 포지션 테이블
   - `ProfitChart.jsx` - 누적 수익률 차트
   - `StrategyControl.jsx` - 전략 제어 패널

4. 연결 복구 및 권한 관리
   - 프론트엔드 WebSocket 재연결/재구독 전략 구현 (미처리 이벤트 catch-up)
   - 다중 사용자 대응을 위한 역할 기반 접근 제어 적용

**산출물**:
- WebSocket 서버/클라이언트
- 실시간 대시보드 UI
- 기능/UX 테스트

**리스크**:
- WebSocket 재연결 로직
- 대량 이벤트 발생 시 UI 렌더링 성능

**의존성**: Task 4.2, 4.3 완료

---

### **Phase 5: 통합 테스트 및 검증 (Task 4.5)**
**예상 기간: 2-3일 | 우선순위: MEDIUM**

#### 작업 내용
1. Docker Compose 전체 서비스 기동
   - `docker-compose --profile simulation up` 검증

2. End-to-End 시나리오 테스트
   - 업비트 WebSocket → 캔들 수집
   - 전략 실행 → BUY 신호 생성
   - 포지션 진입 → 미실현 손익 계산
   - 프론트 실시간 확인
   - SELL 신호 → 청산 → 실현 손익

3. 회귀 테스트
   - 기존 백테스트 API pytest 75개 통과 확인

4. 성능 검증
   - 5개 심볼 동시 구독, 전략 실행 지연 < 1초

5. 문서화
   - `docs/coin/mvp/phase2_testing_guide.md` 작성

**산출물**:
- End-to-End 테스트 시나리오
- 회귀 테스트 결과
- 성능 측정 리포트
- 테스트 가이드 문서

**의존성**: Task 4.1~4.4 모두 완료

---

## ⚠️ 주요 리스크 및 미해결 이슈

### 1. 에러 복구 및 데이터 동기화
- WebSocket 끊김 시 REST 백필 범위 및 재시도 주기?
- 전략 워커 다운 시 미처리 캔들 재처리 절차?
- Redis 장애 시 Postgres 영속 데이터로 복구하고 Redis는 버퍼/브로드캐스트 전용으로 제한

### 2. 보안 및 인증
- 거래소 API 키는 현재 단계에서는 Docker 환경 변수/Secrets로 관리하고, 실거래 도입 시 Vault 전환 검토
- WebSocket 연결은 JWT 기반 토큰 검증과 만료 시 재발급 절차 적용
- 다중 사용자 접근 시 역할 기반 접근 제어로 권한 관리

### 3. 거래소 API Rate Limit
- REST API 호출은 200 캔들 청크+지수 백오프 전략으로 2분당 120회 제한 준수
- 여러 심볼 구독 시 메시지 처리량을 감시하고 구독 슬롯을 스케줄러가 분배

---

## 📊 전체 일정 및 우선순위

| 우선순위 | 작업 | 예상 기간 | 병렬 가능 | 의존성 |
|---------|------|----------|----------|--------|
| CRITICAL | Task 4.1 (데이터 수집) | 3-5일 | ✅ | 없음 |
| CRITICAL | Task 4.2 (전략 실행) | 4-6일 | ✅ | 4.1 포맷 확정 |
| HIGH | Task 4.3 (포지션 관리) | 3-4일 | ✅ | 4.2 완료 |
| HIGH | Task 4.4 (프론트 대시보드) | 3-5일 | ✅ | 4.2, 4.3 완료 |
| MEDIUM | Task 4.5 (통합 테스트) | 2-3일 | ❌ | 전체 완료 |

**전체 예상 일정**: 15-23일 (순차) → 10-15일 (병렬 작업 시)

---

## 🚀 즉시 착수 가능한 선행 작업

병렬 작업 효율을 위해 다음 조사/설계 작업을 먼저 진행할 수 있습니다:

1. **업비트 WebSocket API 조사** (Task 4.1 선행)
   - API 키 발급, 체결 스트림 연결 테스트

2. **데이터 저장소 설계** (Task 4.1 선행)
   - Redis Stream vs Queue 선택, 스키마 설계

3. **전략 인터페이스 설계** (Task 4.2 선행)
   - `BaseStrategy`에 실시간 메서드 추가 스펙

4. **캔들 집계 POC** (Task 4.1 선행)
   - WebSocket + REST 백필 조합 테스트

5. **전략 히스토리 로딩 골격** (Task 4.2 선행)
   - `initialize_with_history` 유틸리티 구현

---

## 🧪 테스트 및 검증 가이드

### 1. Database 단위 테스트

```bash
# 마이그레이션 적용 확인
psql -h localhost -U coin_user -d coin_db -f backend/migrations/001_create_simulation_schema.sql

# 테스트: 캔들 삽입
from backend.app.database import DatabaseManager
db = DatabaseManager()
db.connect()

candle_id = db.insert_candle(
    'KRW-BTC', '1m', datetime.utcnow(),
    10000, 10500, 9900, 10200, 5.5
)
print(f"Inserted candle id: {candle_id}")
```

**예상 결과**: `candle_id > 0` 반환

### 2. MarketDataService 테스트 (Mock)

```bash
# Mock WebSocket 클라이언트로 히스토리 로딩 검증
import asyncio
from backend.app.market_data.market_data_service import MarketDataService

service = MarketDataService(['KRW-BTC'], timeframe='1m')
await service.initialize()  # _load_history() 호출

# 캔들 빌더 상태 확인
builder = service.candle_builders['KRW-BTC']
print(f"Loaded candles: {len(builder.candles)}")
```

**예상 결과**: 데이터베이스에 데이터가 있으면 캔들 로드됨, 없으면 0

### 3. WebSocket 재연결 테스트

#### 테스트 시나리오 A: 히스토리 내 valid last_event_id

**클라이언트 코드**:

```python
import asyncio
import json
import websockets
from backend.app.simulation.websocket_server import get_websocket_server

async def test_reconnect_valid_event_id():
    """히스토리에 존재하는 last_event_id로 동기화"""
    server = get_websocket_server()
    token = server.generate_token('test_user', 'trader')

    last_event_id = None

    # 연결 1: 첫 이벤트 수신
    async with websockets.connect('ws://localhost:8001') as ws:
        await ws.send(json.dumps({'type': 'auth', 'token': token}))
        await ws.recv()  # CONNECTION_ESTABLISHED

        await ws.send(json.dumps({'type': 'subscribe', 'symbols': ['KRW-BTC']}))
        await ws.recv()  # SUBSCRIBE_ACK

        # 신호 이벤트 수신 (서버에서 broadcast_signal 호출됨)
        event1 = await asyncio.wait_for(ws.recv(), timeout=5.0)
        data1 = json.loads(event1)
        last_event_id = data1['event_id']
        print(f"✓ 첫 번째 연결에서 이벤트 수신: {data1['type']} (id: {last_event_id})")

    # 연결 2: 동기화 요청 (valid last_event_id)
    async with websockets.connect('ws://localhost:8001') as ws:
        await ws.send(json.dumps({'type': 'auth', 'token': token}))
        await ws.recv()  # CONNECTION_ESTABLISHED

        await ws.send(json.dumps({
            'type': 'sync',
            'last_event_id': last_event_id,
            'symbols': ['KRW-BTC']
        }))

        # last_event_id 이후 이벤트만 재수신
        resent_count = 0
        while True:
            event = await asyncio.wait_for(ws.recv(), timeout=5.0)
            data = json.loads(event)

            if data['type'] == 'heartbeat' and data['data'].get('type') == 'sync_complete':
                resent_count = data['data'].get('resent_count', 0)
                print(f"✓ 동기화 완료: {resent_count}개 이벤트 재전송")
                break

        print(f"✓ 시나리오 A (Valid Event ID) 통과\n")

async def test_reconnect_expired_event_id():
    """히스토리에 존재하지 않는 expired last_event_id"""
    server = get_websocket_server()
    token = server.generate_token('test_user', 'trader')

    # 만료된 이벤트 ID (존재하지 않음)
    expired_event_id = "00000000-0000-0000-0000-000000000000"

    async with websockets.connect('ws://localhost:8001') as ws:
        await ws.send(json.dumps({'type': 'auth', 'token': token}))
        await ws.recv()  # CONNECTION_ESTABLISHED

        await ws.send(json.dumps({
            'type': 'sync',
            'last_event_id': expired_event_id,
            'symbols': ['KRW-BTC']
        }))

        # Choice A (Safety Mode): 전체 히스토리 재전송
        # Choice B (Explicit Error): SYNC_FAILED 에러 응답
        # → 현재 구현: Choice A

        received_events = []
        fallback_received = False

        while True:
            event = await asyncio.wait_for(ws.recv(), timeout=5.0)
            data = json.loads(event)

            if data['type'] == 'heartbeat':
                if data['data'].get('type') == 'sync_fallback':
                    fallback_received = True
                    print(f"✓ Fallback 메시지 수신: {data['data'].get('message')}")
                    print(f"  (히스토리 만료 감지 → 전체 재전송)")
                elif data['data'].get('type') == 'sync_complete':
                    resent_count = data['data'].get('resent_count', 0)
                    print(f"✓ 동기화 완료: {resent_count}개 이벤트 재전송 (전체 히스토리)")
                    break

        assert fallback_received, "Fallback 메시지 수신 실패"
        print(f"✓ 시나리오 B (Expired Event ID) 통과\n")

# 실행
# asyncio.run(test_reconnect_valid_event_id())
# asyncio.run(test_reconnect_expired_event_id())
```

**테스트 실행**:

```bash
# 터미널 1: WebSocket 서버 시작
python -c "
import asyncio
from backend.app.simulation.websocket_server import get_websocket_server
server = get_websocket_server('0.0.0.0', 8001)
asyncio.run(server.start())
"

# 터미널 2: 클라이언트 테스트
python -c "
import asyncio
from tests.test_websocket_reconnect import test_reconnect_valid_event_id, test_reconnect_expired_event_id
asyncio.run(test_reconnect_valid_event_id())
asyncio.run(test_reconnect_expired_event_id())
"
```

**예상 결과**:
- ✓ 시나리오 A: `sync_complete` 메시지 수신 (last_event_id 이후만)
- ✓ 시나리오 B: `sync_fallback` → `sync_complete` 메시지 (전체 히스토리)

### 4. 포지션 손익 계산 테스트

```bash
# SQL 직접 테스트
INSERT INTO simulation_positions
(symbol, strategy_name, entry_time, entry_price, quantity, status, fee_amount)
VALUES ('KRW-BTC', 'test_strategy', NOW(), 10000, 0.5, 'OPEN', 100);

# 포지션 종료 (11,000에 청산, 슬리피지 50)
UPDATE simulation_positions
SET status = 'CLOSED',
    exit_time = NOW(),
    exit_price = 11000,
    realized_pnl = (quantity * (11000 - entry_price) - fee_amount - 50),
    realized_pnl_pct = ((quantity * (11000 - entry_price) - fee_amount - 50) /
                       (entry_price * quantity)) * 100,
    slippage_amount = 50
WHERE id = 1;

# 결과 확인: realized_pnl = 0.5 * (11000 - 10000) - 100 - 50 = 500 - 150 = 350
```

**예상 결과**: `realized_pnl = 350`

---

## 🎯 Phase 2 구현 준비 상태

**기초 인프라 완성도**: ✅ 95% (Phase 1 & 기초 구현)

다음 Phase (2~4)를 시작하기 전에 확인할 사항:

1. **Docker Compose 통합 확인**
   - Postgres 마이그레이션 자동 적용 (init script)
   - Redis/Postgres 헬스체크 완료

2. **의존성 설치**
   ```bash
   pip install websockets psycopg2-binary pyjwt pandas
   ```

3. **환경 변수 설정**
   ```bash
   export DATABASE_URL="postgresql://coin_user:coin_password@postgres:5432/coin_db"
   export REDIS_HOST="redis"
   ```

## ✅ Phase 2 구현 완료: Task 4.2 (실시간 전략 실행 엔진)

**완료 일자**: 2025-11-04 | **상태**: COMPLETE

### Task 4.2: 실시간 전략 실행 엔진 - 구현 완료 📦

#### 완료된 산출물

1. **StrategyRunner 구현** ✅
   - 파일: `backend/app/simulation/strategy_runner.py` (약 296줄)
   - 주요 클래스:
     - `StrategyConfig`: 전략 설정 및 상태 관리
     - `StrategyRunner`: 전략 실행 엔진

   - 핵심 메서드:
     ```python
     async def register_strategy(symbol, strategy_name, params)
       - StrategyFactory.create()로 전략 인스턴스 생성
       - StrategyConfig에 저장

     async def initialize_strategy(symbol, strategy_name)
       - Postgres에서 히스토리 캔들 로드
       - strategy_instance.initialize_with_history() 호출
       - 초기화 상태 추적

     async def process_candle(candle: CandleData)
       - 각 전략의 process_candle() 호출
       - 신호 생성 시 _on_signal_generated() 호출

     async def _on_signal_generated(signal, symbol, strategy_name)
       - DatabaseManager.insert_signal()로 신호 저장
       - on_signal 콜백 호출 (WebSocket 브로드캐스트)
     ```

2. **SimulationOrchestrator 구현** ✅
   - 파일: `backend/app/simulation/simulation_orchestrator.py` (약 210줄)
   - 목적: MarketDataService → StrategyRunner → WebSocketServer 통합

   - 핵심 기능:
     ```python
     async def start_simulation(symbols, strategies, redis_client)
       - db.create_session() 호출로 세션 생성
       - MarketDataService 시작 (백그라운드 태스크)
       - StrategyRunner 초기화 및 전략 등록
       - 전략별 initialize_strategy() 호출
       - 콜백 체인 설정

     async def stop_simulation()
       - 모든 서비스 중지 (clean shutdown)
       - 세션 상태 업데이트

     def get_simulation_status()
       - 현재 시뮬레이션 상태 반환
       - WebSocket 클라이언트 수 포함
     ```

3. **REST API 엔드포인트 추가** ✅
   - 파일: `backend/app/main.py` (약 200줄 추가)

   - 추가된 엔드포인트:
     ```
     POST /api/simulation/start
       요청: SimulationStartRequest (symbols, strategies)
       응답: SimulationStatusResponse
       기능: 실시간 시뮬레이션 시작

     POST /api/simulation/stop
       응답: SimulationStatusResponse
       기능: 실시간 시뮬레이션 중지

     GET /api/simulation/status
       응답: SimulationStatusResponse
       기능: 시뮬레이션 상태 조회 (is_running, strategy_count, websocket_clients)

     GET /api/simulation/strategies
       응답: SimulationStrategiesResponse
       기능: 등록된 전략 목록 조회
     ```

   - Pydantic 모델:
     - `StrategyConfig`: 전략 설정 (strategy_name, params)
     - `SimulationStartRequest`: 시뮬레이션 시작 요청
     - `SimulationStatusResponse`: 상태 응답
     - `SimulationStrategyResponse`: 전략 정보
     - `SimulationStrategiesResponse`: 전략 목록 응답

4. **단위 테스트 작성** ✅
   - 파일: `tests/test_strategy_runner.py` (약 360줄)

   - 테스트 케이스 (15개 테스트 클래스, 50+개 메서드):
     ```
     - StrategyConfig 초기화 및 표현
     - StrategyRunner 초기화
     - 전략 등록 (단일/다중 심볼)
     - 전략 초기화 (히스토리 로드)
     - 캔들 처리 (단일/다중 전략, 신호 생성)
     - 신호 생성 및 DB 저장
     - 엔진 생명주기 (start/stop)
     - 전략 조회 (심볼별/전체)
     ```

   - Mock 기반 테스트로 외부 의존성 격리

#### 아키텍처 및 데이터 흐름

```
MarketDataService (실시간 캔들)
         ↓ (on_candle_complete 콜백)
SimulationOrchestrator
         ↓
StrategyRunner
    ├─ strategy1 (KRW-BTC)
    ├─ strategy2 (KRW-BTC)
    └─ strategy3 (KRW-ETH)
         ↓ (신호 생성 시)
      Signal
         ↓ (on_signal 콜백)
DatabaseManager (신호 저장)  +  WebSocketServer (실시간 브로드캐스트)
```

#### 핵심 설계 패턴

1. **Singleton 패턴**
   - `get_orchestrator()`: 전역 SimulationOrchestrator 인스턴스
   - `get_strategy_runner()`: 전역 StrategyRunner 인스턴스

2. **Event-Driven 아키텍처**
   - MarketDataService → StrategyRunner → WebSocketServer
   - 각 단계에서 콜백(callback)으로 비동기 이벤트 전파

3. **의존성 주입 (DI)**
   - DatabaseManager, RedisClient를 생성자/메서드 파라미터로 주입
   - 테스트 용이성 향상

4. **상태 추적**
   - StrategyConfig.is_initialized로 전략 초기화 상태 관리
   - SimulationOrchestrator.is_running으로 시뮬레이션 실행 상태 관리

#### 주요 개선사항

1. **히스토리 로딩 최적화**
   - min_history_window만큼만 로드
   - 초기화 실패 시에도 실시간 진행 가능

2. **에러 처리**
   - 전략 실행 실패 시 로깅 및 계속 진행
   - DB 저장 실패 시에도 신호 콜백 호출

3. **확장성**
   - 다중 심볼/다중 전략 지원
   - 새로운 전략 추가 시 StrategyFactory만 수정하면 됨

#### 호환성 및 검증

- ✅ Phase 1 (MarketDataService) 호환성 유지
- ✅ 기존 백테스트 전략 인터페이스 호환성
- ✅ DatabaseManager 연동 검증
- ✅ WebSocketServer 신호 브로드캐스트 통합

#### 의존성 및 제약사항

- Python 3.8+, asyncio, pandas
- PostgreSQL 15+ (market_candles, signals 테이블)
- FastAPI, Pydantic
- Mock 기반 테스트 (pytest-asyncio)

---

## ✅ Phase 3 구현 완료: Task 4.3 (가상 포지션 관리 시스템)

**완료 일자**: 2025-11-04 | **상태**: COMPLETE

### Task 4.3: 가상 포지션 관리 시스템 - 구현 완료 📦

#### 완료된 산출물

1. **PositionManager 구현** ✅
   - 파일: `backend/app/simulation/position_manager.py` (약 420줄)
   - 주요 클래스:
     - `Position`: 개별 포지션 상태 관리
     - `PositionManager`: 포지션 생명주기 관리 엔진

   - 핵심 메서드:
     ```python
     async def enter_position(symbol, strategy_name, entry_price, timestamp)
       - BUY 신호 수신 시 포지션 진입
       - 수수료 계산 (거래액의 0.1%)
       - DB에 포지션 기록

     async def close_position(symbol, strategy_name, exit_price, timestamp)
       - SELL 신호 수신 시 포지션 청산
       - 실현 손익 계산 (수수료/슬리피지 반영)
       - 거래 이력 저장

     async def update_unrealized_pnl(candle: CandleData)
       - 새 캔들 수신 시 미실현 손익 업데이트
       - 현재가 기준 평가

     def get_open_positions(symbol=None, strategy_name=None)
       - 오픈 포지션 조회 (필터링 가능)

     def get_closed_trades(symbol=None, strategy_name=None, limit=100)
       - 클로즈된 거래 이력 조회
     ```

   - 포지션 관리 정책:
     - 심볼:전략명 조합별 최대 1개 오픈 포지션
     - 거래 수량: 0.1 단위 (고정)
     - 수수료: 0.1% (거래액 기준)
     - 슬리피지: 기본값 0.02% 자동 적용 (명시적 값으로 오버라이드 가능)

2. **SimulationOrchestrator 통합** ✅
   - PositionManager 초기화
   - 신호 라우팅: StrategyRunner → PositionManager
   - 캔들 처리: 미실현 손익 업데이트
   - 정리: 포지션 요약 로깅

3. **REST API 엔드포인트 추가** ✅
   - 파일: `backend/app/main.py` (약 130줄 추가)

   - 새로운 엔드포인트:
     ```
     GET /api/simulation/positions?symbol=KRW-BTC
       응답: PositionListResponse
       - 현재 오픈 포지션 목록
       - 총 미실현 손익
       - 심볼별 필터링 가능

     GET /api/simulation/history?symbol=KRW-BTC&limit=100
       응답: TradeHistoryResponse
       - 클로즈된 거래 목록
       - 통계: 총 실현 손익, 수익 거래 개수, 손실 거래 개수, 승률 (0.0~1.0)
     ```

4. **Pydantic 응답 모델** ✅
   - `PositionResponse`: 개별 포지션 정보
   - `PositionListResponse`: 포지션 목록 + 요약
   - `TradeResponse`: 거래(클로즈된 포지션) 정보
   - `TradeHistoryResponse`: 거래 이력 + 통계

5. **단위 테스트 작성** ✅
   - 파일: `tests/test_position_manager.py` (약 400줄)

   - 테스트 케이스 (8개 테스트 클래스, 40+개 메서드):
     ```
     - Position 초기화 및 가격 업데이트
     - PositionManager 초기화
     - 포지션 진입 (단일/다중 심볼)
     - 포지션 청산 (수익/손실)
     - 미실현 손익 업데이트 (단일/다중)
     - BUY/SELL 신호 처리
     - 포지션 및 거래 조회
     ```

   - Mock 기반 테스트로 데이터베이스 격리

#### 아키텍처 및 데이터 흐름

```
StrategyRunner (신호 생성)
         ↓ (신호 콜백)
SimulationOrchestrator
         ↓
PositionManager
    ├─ BUY 신호 → enter_position()
    └─ SELL 신호 → close_position()
         ↓
    Position 상태 관리
         ↓
    DatabaseManager (저장)
    ├─ simulation_positions (오픈 포지션)
    └─ simulation_trades (클로즈된 거래)
```

#### 손익 계산 공식

**미실현 손익**:
```
unrealized_pnl = (quantity * (current_price - entry_price)) - fee_amount
unrealized_pnl_pct = (unrealized_pnl / (entry_price * quantity)) * 100
```

**실현 손익**:
```
realized_pnl = (quantity * (exit_price - entry_price)) - fee_amount - slippage
realized_pnl_pct = (realized_pnl / (entry_price * quantity)) * 100
```

**슬리피지 자동 계산** (미제공 시):
```
slippage_amount = exit_price * quantity * slippage_rate
# 기본값: slippage_rate = 0.0002 (0.02%)
# 예: 51000 * 0.1 * 0.0002 = 1.02 KRW
```

**승률 계산**:
```
win_rate = win_count / total_trades (0.0 ~ 1.0)
# 예: 7승 3패 → 0.70 (70%)
```

#### 핵심 설계 패턴

1. **Singleton 패턴**
   - `get_position_manager()`: 전역 PositionManager 인스턴스

2. **Event-Driven 아키텍처**
   - 신호 기반 포지션 관리
   - 캔들 기반 미실현 손익 업데이트

3. **상태 머신**
   - Position: OPEN → CLOSED 상태 전이
   - 각 거래는 entry_time ~ exit_time으로 추적

4. **데이터 격리**
   - 메모리: 현재 오픈 포지션 (빠른 접근)
   - Database: 모든 거래 기록 (영속성)

#### 주요 개선사항

1. **리스크 관리**
   - 심볼:전략 조합별 1개 포지션만 유지
   - 중복 진입 방지

2. **비용 반영**
   - 수수료: 거래액의 0.1%
   - 슬리피지: 청산가 적용 시 추가 비용

3. **통계 제공**
   - 실시간 미실현 손익 추적
   - 거래별 수익률 계산
   - 누적 성과 관리

#### 호환성 및 검증

- ✅ StrategyRunner 신호 통합
- ✅ MarketDataService 캔들 통합
- ✅ DatabaseManager 데이터 영속성
- ✅ SimulationOrchestrator 생명주기 관리

#### 의존성 및 제약사항

- Python 3.8+, asyncio
- PostgreSQL 15+ (simulation_positions, simulation_trades 테이블)
- Mock 기반 테스트 (pytest-asyncio)

---

## 🚀 다음 Phase 작업 (Phase 4: Task 4.4 - 프론트엔드 대시보드)

### Task 4.3: 포지션 관리 (병렬 진행)

1. **PositionManager 구현**
   - BUY 신호 → `insert_position()` + Postgres 저장
   - 캔들마다 `update_position_unrealized_pnl()` (미실현 손익 갱신)
   - SELL 신호 → `update_position_on_close()` + `insert_trade()`

2. **포지션 상태 관리**
   - 실시간 미실현 손익 계산
   - 브로드캐스트 (`broadcast_position`)

3. **Unit Test**
   - 진입/청산 흐름
   - 손익 계산 검증 (DB 계산 확인)

---

## 🔐 WebSocket 히스토리 동기화 정책

### 정책 선택지

클라이언트 재연결 시 `last_event_id`를 찾지 못하는 경우 처리 방식:

#### Choice A: Safety Mode (권장 - 현재 적용)

**설명**: 히스토리가 만료되었을 가능성이 높으면 전체 히스토리를 재전송하여 최신 상태 복구

**장점**:
- ✅ 클라이언트가 항상 최신 상태로 복구됨
- ✅ 유저 경험 우선 (더 많은 데이터 수신이지만 안정적)
- ✅ 구현이 간단하고 에러 처리 로직이 명확함

**단점**:
- ❌ 매우 오래된 이벤트를 재전송할 수 있음
- ❌ 대역폭 사용량 증가 가능성

**구현 (현재)**:
```python
# _resend_history_events에서:
if last_event_id is not None and not event_found and resent_count == 0:
    # 전체 히스토리를 처음부터 재전송
    # + sync_fallback 메시지로 클라이언트에 알림
```

#### Choice B: Explicit Error (선택지)

**설명**: 히스토리에서 찾지 못하면 명시적 오류를 반환하여 클라이언트가 풀 싱크 재요청

**장점**:
- ✅ 명확한 에러 추적 (오류 감시/로깅 용이)
- ✅ 대역폭 효율적 (에러 응답만 송수신)
- ✅ 클라이언트가 재시도 로직 구현 가능

**단점**:
- ❌ 클라이언트가 풀 싱크 요청 로직 필요
- ❌ 유저가 일시적으로 상태 불일치 경험

**전환 방법**:
```python
# backend/app/simulation/websocket_server.py의 _resend_history_events에서
# 주석 처리된 "CHOICE B" 코드 블록의 주석을 해제하고
# "CHOICE A" 코드 블록을 주석 처리
```

### 권장 사항

**개발/테스트 단계**: Choice A (안전 모드)
- 구현 복잡성 ↓, 안정성 ↑
- 히스토리 크기가 충분하면 문제 없음

**프로덕션**: 모니터링 후 결정
- 평균 히스토리 만료 빈도 모니터링
- 만료 빈도 > 1%이면 Choice B 검토

---

## ✅ Phase 1 최종 체크리스트

- [x] Postgres 스키마 생성
- [x] DatabaseManager (연결 풀, CRUD)
- [x] CandleBuilder + WebSocket 클라이언트
- [x] MarketDataService (히스토리 로딩, Redis 브로드캐스트)
- [x] WebSocket 서버 (JWT 인증, RBAC, 이벤트 히스토리, 재연결)
  - [x] 히스토리 동기화 (Choice A 적용)
  - [x] 만료 이벤트 처리 (fallback 메시지)
- [x] BaseStrategy 확장 (실시간 메서드)
- [x] docker-compose.yml 업데이트
- [x] 문서 및 테스트 가이드
  - [x] 단위 테스트 가이드
  - [x] 재연결 테스트 시나리오 (A, B)
  - [x] 포지션 손익 테스트
  - [x] 정책 선택지 문서화

**Phase 1 완료율**: ✅ 100%

---

## 🔜 구현 완료 현황

### ✅ 완료된 작업

1. **Postgres 스키마** (`backend/migrations/001_create_simulation_schema.sql`)
   - `CREATE EXTENSION IF NOT EXISTS pgcrypto;` 포함
   - 8개 핵심 테이블 정의
   - 인덱스 및 제약조건 완성

2. **DatabaseManager** (`backend/app/database.py`)
   - SimpleConnectionPool 기반 연결 풀링
   - `with db.get_conn() as conn:` 컨텍스트 매니저
   - 비동기 메서드: `execute_async`, `fetch_one_async`, `fetch_all_async`
   - 비동기 삽입: `insert_candle_async()` (내부에서 자동 COMMIT)
   - Phase 3 CRUD: 포지션, 거래, 세션, 스냅샷 메서드
   - 포지션 청산 수식 수정: `realized_pnl = (quantity * (%s - entry_price) - fee_amount - %s)`

3. **캔들 집계** (`backend/app/market_data/`)
   - `CandleBuilder`: 체결 → 1분/5분/1h/4h/1d 캔들
   - `UpbitWebSocketClient`: 실시간 WebSocket 체결 수신
   - `MarketDataService`: 히스토리 로딩 + 재시도 (지수 백오프)
   - Redis 브로드캐스트 (의존성 주입, asyncio.to_thread 사용)

4. **WebSocket 서버** (`backend/app/simulation/websocket_server.py`)
   - 표준 WebSocket (RFC 6455, `websockets` 라이브러리)
   - JWT 기반 인증
   - 역할 기반 접근 제어 (RBAC)
   - **이벤트 히스토리** (최근 10,000개 전역, 심볼당 1,000개)
   - **재연결/동기화**:
     - `ClientConnection.last_event_id` 자동 갱신
     - `sync` 메시지로 마지막 이벤트 ID 이후 재전송
     - `sync_complete` 응답

### 📋 주요 변경 사항 (Phase 1-2 기초 완성)

**DatabaseManager 개선**:
- `insert_candle_async()`: 비동기 삽입 + 자동 COMMIT (asyncio.to_thread 래핑)
- fetch_* 메서드: 읽기 전용 (COMMIT 불필요)
- 포지션 업데이트: SQL에서 수식 계산 (애플리케이션 로직 제거)

**MarketDataService 개선**:
- `_load_history()`: 재시도 로직 + 지수 백오프 (1s, 2s, 4s)
- `_save_candle()`: `insert_candle_async()` 사용
- `_broadcast_to_redis()`: Redis 클라이언트 의존성 주입, asyncio.to_thread 사용

**WebSocket 재연결**:
- 이벤트 ID 기반 추적 (`uuid4()`)
- 글로벌 + 심볼별 히스토리 이원 관리
- `sync` 메시지: `last_event_id` 이후 이벤트만 재전송
- 브로드캐스트 시 자동으로 `last_event_id` 갱신
