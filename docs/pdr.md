# PDR: 코인/주식용 백테스팅 · 실전 시뮬레이션 · 자동매매 모듈

## 1. 목적(Purpose)

트레이더/운영자가 전략 아이디어(예: 거래량 급증+장대양봉, 매물대 돌파) 를 빠르게 데이터로 검증하고,

검증된 전략을 실시간 시뮬레이션(모의·페이퍼) 으로 돌려본 뒤,

조건이 만족되면 자동으로 실제 거래소/브로커에 주문할 수 있는 엔드투엔드 파이프라인을 제공한다.

전략은 코인 종목별로 성과가 다르다는 걸 전제로 하며, 백테스트 시 전 종목 일괄 실행 후 종목별 적합도 리포트를 자동으로 만든다.

대상 환경은 PSA-NEXT / PSA-NEXT-HTS-COIN의 기존 구조(FastAPI + React + Docker + /data/... 실물파일) 에 자연스럽게 탑재한다.

## 2. 범위(Scope)

### In Scope

**전략 정의 레이어**

- 거래량 급증 + 장대양봉 패턴
- 매물대(가격대별 누적거래량 + 머문일수) 돌파 패턴
- 멀티 타임프레임(MTF: 일봉+시간봉+분봉) 조합 패턴
- 파라미터 스윕(예: 거래량 1.2x/1.5x/2.0x, 돌파강도 1%/2%/3%)

**백테스트 엔진**

- 단일 종목/단일 전략 백테스트
- 전체 종목 일괄 백테스트("코인 전체에 똑같이 적용되지는 않는다"를 전제로, 종목별 통계 분리)
- 수수료/슬리피지 반영
- N봉 후 수익률, 최대 낙폭, 샘플 수, 승률 산출

**실전 시뮬레이션(페이퍼 트레이딩)**

- 실시간 시세/캔들 들어오면 전략 로직에 그대로 통과
- 실제 주문은 안 내고 가상의 포지션/현금으로 체결 기록
- 대시보드에서 시그널·포지션·P/L 실시간 확인

**자동매매 실행 레이어**

- 거래소 REST/Websocket 연동 어댑터(Upbit/바이낸스 등 1~2개부터)
- 전략에서 발생한 시그널을 주문으로 변환
- 리스크 룰(최대 포지션, 일일 손실 한도) 선차단

**Frontend 대시보드**

- 전략 파라미터 입력 → 백테스트 실행 → 결과테이블/차트 뷰
- 실시간 시그널/포지션/체결 로그 뷰
- 코인별 전략 적합도 테이블

### Out of Scope (이번 버전)

- 고급 포트폴리오 최적화(마코위츠, 리밸런싱 스케줄러)
- 옵션/선물 파생상품 전략
- 멀티계좌/멀티거래소 자금 라우팅
- 초단타(HFT)급 밀리초 체결 최적화

## 3. 이해관계자(Stakeholders)

- **시스템 운영자**: 전략 등록/수정, 자동매매 on/off, 리스크 파라미터 설정
- **전략 개발자**: 새 패턴 구현, 파라미터 스윕, 백테스트 성능 검증
- **트레이더/사용자**: 프론트에서 전략 고르고 실전 시뮬레이션 모드로 확인
- **플랫폼 관리자(PSA-NEXT)**: 도커·로그·Nginx 경로·/data 마운트 관리

## 4. 주요 시나리오(Use Cases)

### UC1. 패턴 기반 백테스트 실행

사용자가 프론트에서 패턴 선택

- "거래량 급증 + 장대양봉"
- "매물대 상위 20% 영역 돌파"

파라미터 입력

- 기간: 최근 90일
- 거래량 기준: 최근 20봉 평균 × 1.5
- 돌파 강도: 종가가 매물대 위 +1%
- 타임프레임: 1h + 5m

/api/backtest/run 호출

백엔드가 /data/{SYMBOL}/{interval}/{year}.parquet 전부 순회

각 심볼별로 결과 JSON 생성 → 합산해 응답

프론트가 "코인별 승률/평균수익/MDD/샘플수" 테이블 표시

### UC2. 실전 시뮬레이션(페이퍼)

사용자가 전략을 "실시간 모드"로 전환

실시간 캔들이 들어올 때마다 같은 전략 로직 적용

시그널 발생 시 가상 포지션/체결 저장

대시보드에서 시그널 스트림, 포지션, P/L 표시

사용자가 특정 코인에서 신호가 너무 잦으면 해당 코인만 disable

### UC3. 자동매매

사용자가 전략을 "auto = on"으로 설정

시그널 발생

리스크 룰 체크 (일손실, 종목별 포지션 수, 슬리피지 허용범위)

거래소 API로 실제 주문 전송

체결 결과를 대시보드에 반영하고 백엔드 DB에 영구 저장

실패 시 재시도/알림

## 5. 기능 요구사항(FR)

### FR-1 백테스트 엔진

- **FR-1.1**: 단일 전략을 단일 심볼/단일 타임프레임에 대해 실행할 수 있어야 한다.
- **FR-1.2**: 단일 전략을 전체 심볼에 대해 일괄 실행할 수 있어야 한다.
- **FR-1.3**: 거래비용(수수료 %)와 슬리피지(%)를 시뮬레이션에 반영할 수 있어야 한다.
- **FR-1.4**: 결과로 승률, 평균 수익률, 최대 낙폭, 샘플 수, 신호 날짜 목록을 반환해야 한다.
- **FR-1.5**: 매물대 기반 전략의 경우, "매물대 지속일수"와 "돌파봉 타입(일봉/시간봉/분봉)"을 결과에 포함해야 한다.
- **FR-1.6**: 파라미터 세트를 여러 개 보낸 경우, 모든 조합을 돌고 결과를 리스트로 반환해야 한다(파라미터 스윕).

### FR-2 전략 정의

- **FR-2.1**: "거래량 급증 + 장대양봉" 전략은
  - (1) 기준기간 평균거래량 대비 배수
  - (2) 몸통 크기(%)
  - (3) 위/아래 꼬리 비율
  을 파라미터로 받아야 한다.

- **FR-2.2**: "매물대 돌파" 전략은
  - (1) 매물대 산출용 윈도기간(N일)
  - (2) 매물대 상위 비중(상위 10%/20%/30%)
  - (3) 돌파 확인용 초과율(1%, 2% …)
  - (4) 확인용 타임프레임(1d, 1h, 5m)
  을 파라미터로 받아야 한다.

- **FR-2.3**: 전략은 코인별로 파라미터를 덮어쓰기 할 수 있어야 한다. (공통 파라미터 + per-symbol override)

### FR-3 실전 시뮬레이션

- **FR-3.1**: 실시간 캔들이 들어오면 백테스트와 동일한 로직으로 시그널을 생성해야 한다.
- **FR-3.2**: 생성된 시그널은 실제 주문 없이 가상 포지션으로 기록한다.
- **FR-3.3**: 프론트에서 현재 시그널·포지션·누적P/L을 조회할 수 있어야 한다.
- **FR-3.4**: 시뮬레이션과 실제 자동매매의 로직 차이는 "주문 실행 유무" 한 가지로만 유지한다.

### FR-4 자동매매

- **FR-4.1**: 시그널이 생성되면 거래소 API로 주문을 보낼 수 있어야 한다.
- **FR-4.2**: 주문 전 리스크 룰을 검증해야 한다. (일손실, 최대 포지션, 허용 슬리피지)
- **FR-4.3**: 주문 실패/부분체결/재시도 결과는 모두 로깅하고 프론트에서 볼 수 있어야 한다.
- **FR-4.4**: 전략별로 "auto=on/off" 플래그를 가질 수 있어야 한다.
- **FR-4.5**: 특정 심볼만 자동매매에서 제외할 수 있어야 한다.

### FR-5 프론트엔드

- **FR-5.1**: 전략 파라미터 입력 폼
- **FR-5.2**: 백테스트 결과 테이블 (코인별 행)
- **FR-5.3**: 파라미터별 성과 히트맵(간단 그래프면 OK)
- **FR-5.4**: 실시간 시그널 스트림 뷰
- **FR-5.5**: 포지션/체결 로그 뷰

## 6. 비기능 요구사항(NFR)

- **NFR-1**: 백테스트는 도커 컨테이너 내에서 /data 마운트만으로 실행 가능해야 한다. (당신 시스템 원칙)
- **NFR-2**: 1개 전략 × 100개 심볼 × 1년(일봉) 정도는 타임아웃 없이 한 번에 처리 가능해야 한다. (배치 기준)
- **NFR-3**: API 응답은 10초 이상 걸릴 경우 비동기 태스크 ID를 반환하고, 프론트는 폴링으로 결과를 가져간다. (단, 지금 환경에선 sync로 먼저)
- **NFR-4**: 로그는 /var/log/psa-next/trading/ 아래 일자별 분리
- **NFR-5**: 운영/테스트 전략은 분리된 DB 테이블을 사용해야 한다.

## 7. 데이터 구조(예시)

### 7.1 백엔드 응답 예시

```json
{
  "strategy": "volume_long_candle",
  "params": {
    "vol_ma_window": 20,
    "vol_multiplier": 1.5,
    "body_pct": 0.02
  },
  "run_period": "2025-01-01:2025-10-31",
  "symbols": [
    {
      "symbol": "BTC_KRW",
      "signals": 42,
      "win_rate": 0.59,
      "avg_return_1d": 0.0065,
      "max_drawdown": -0.031,
      "avg_hold_days": 2.1
    },
    {
      "symbol": "XRP_KRW",
      "signals": 85,
      "win_rate": 0.63,
      "avg_return_1d": 0.0081,
      "max_drawdown": -0.045
    }
  ]
}
```

### 7.2 실시간 시그널 스트림 포맷

```json
{
  "timestamp": "2025-10-31T14:02:00+09:00",
  "symbol": "SOL_KRW",
  "strategy": "volume_zone_breakout",
  "side": "buy",
  "price": 143_500,
  "confidence": 0.74,
  "auto": true
}
```

## 8. 리스크/주의사항

- **코인마다 전략 성과가 다름** → 반드시 종목별로 저장하고 보여줘야 한다.
- **데이터 품질** → 빵 구간, 시세 틱누락 있으면 매물대가 이상하게 나옴 → 전처리 파이프라인 필요.
- **실거래 연동** → 거래소 API rate-limit, 체결 지연, 슬리피지 반영 필수.
- **과최적화(Overfitting)** → 파라미터 스윕을 너무 촘촘히 하면 "백테스트에서는 잘 되는데 실전에서 죽는" 문제가 생김 → 최소 샘플 수(MIN_N) 체크.

## 9. 단계적 릴리즈(Phase)

### Phase 1 (백테스트만)

- volume_long_candle, volume_zone_breakout 2개 전략만
- 일봉 기준
- 전체 심볼 일괄 백테스트
- 결과 JSON + React 테이블

### Phase 2 (실전 시뮬)

- 1h / 5m 타임프레임 추가
- 실시간 캔들 인입 → 동일 로직 → 가상 포지션
- 프론트 실시간 뷰

### Phase 3 (자동매매)

- 거래소 1곳 연동(Upbit or Binance)
- auto=on 된 전략만 주문 발행
- 리스크 룰 추가

## 요약

이렇게 하면 지금까지 우리가 얘기했던

- "거래량이 평소보다 많고 장대양봉"
- "매물대가 며칠 쌓였고 그걸 넘는 봉이 나오니 어떻더라"
- "모든 코인에 똑같이 적용되지는 않음 → 종목별 통계 분리"

이 세 가지를 전부 한 프레임워크 안에 넣을 수 있어요.
